use clap::Parser;
use indexmap::{IndexMap, IndexSet};
use rustdoc_types::{Crate, Item, ItemEnum, Visibility};
use serde::Deserialize;
use serde_derive::Serialize;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
pub struct Args {
    /// Paths to json files generated by `rustdoc -p <crate> --output-format json`
    #[clap(short, long, value_parser)]
    pub json: Vec<String>,

    /// The path to toml config file which contains the types to be wrapped and overrides
    #[clap(short, long, value_parser)]
    pub config: String,

    #[clap(short, long, value_parser, default_value = "templates")]
    pub templates: String,

    #[clap(short, long, value_parser, default_value = "generated.rs")]
    pub output: String,

    #[clap(short, long, value_parser, num_args(0..))]
    pub type_allowlist: Option<Vec<String>>,

    /// if true the excluded methods will show up as commented out code with reasons for exclusion
    #[clap(long)]
    pub print_errors: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Config {
    #[serde(skip_deserializing, default)]
    pub types: IndexMap<String, NewtypeConfig>,

    /// Describes the set of non generic things which are representible
    /// as simple lua types and don't need UserData proxies
    pub primitives: IndexSet<String>,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq, Clone)]
pub struct NewtypeConfig {
    #[serde(rename = "type")]
    pub type_: String,

    #[serde(default)]
    pub source: Source,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash, Clone)]
pub struct Source(pub String);

impl Default for Source {
    fn default() -> Self {
        Self("bevy".to_string())
    }
}

impl NewtypeConfig {
    /// Returns true if this Type:
    /// - describes the given item element
    /// - if the element is fully described in the source crate
    /// - if the element is a struct or enum
    /// - if the element has no generics
    pub fn matches_result(&self, item: &Item, source: &Crate) -> bool {
        match &item.inner {
            ItemEnum::Struct(s) => {
                if !s.generics.params.is_empty() {
                    return false;
                }
            }
            ItemEnum::Enum(_) => {}
            _ => return false,
        };

        if source.external_crates.contains_key(&item.crate_id) {
            return false;
        };

        matches!(item.visibility, Visibility::Public)
    }
}

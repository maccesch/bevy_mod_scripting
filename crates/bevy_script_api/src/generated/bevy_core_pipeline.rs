// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// Applies a bloom effect to an HDR-enabled 2d or 3d camera.

/// Bloom emulates an effect found in real cameras and the human eye,

/// causing halos to appear around very bright parts of the scene.

/// See also <https://en.wikipedia.org/wiki/Bloom_(shader_effect)>.

/// # Usage Notes

/// **Bloom is currently not compatible with WebGL2.**

/// Often used in conjunction with `bevy_pbr::StandardMaterial::emissive` for 3d meshes.

/// Bloom is best used alongside a tonemapping function that desaturates bright colors,

/// such as [`crate::tonemapping::Tonemapping::TonyMcMapface`].

/// Bevy's implementation uses a parametric curve to blend between a set of

/// blurred (lower frequency) images generated from the camera's view.

/// See <https://starlederer.github.io/bloom/> for a visualization of the parametric curve

/// used in Bevy as well as a visualization of the curve's respective scattering profile.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bloom::settings::BloomSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> bloom::settings::BloomSettings;
}
"#]
)]




pub struct LuaBloomSettings{
    
    
        intensity:f32,


    
        low_frequency_boost:f32,


    
        low_frequency_boost_curvature:f32,


    
        high_pass_frequency:f32,


    
        #[lua(output(proxy))]prefilter_settings:bloom::settings::BloomPrefilterSettings,


    
        #[lua(output(proxy))]composite_mode:bloom::settings::BloomCompositeMode,


    
    
}

    
/// Applies a threshold filter to the input image to extract the brightest

/// regions before blurring them and compositing back onto the original image.

/// These settings are useful when emulating the 1990s-2000s game look.

/// # Considerations

/// * Changing these settings creates a physically inaccurate image

/// * Changing these settings makes it easy to make the final result look worse

/// * Non-default prefilter settings should be used in conjuction with [`BloomCompositeMode::Additive`]


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bloom::settings::BloomPrefilterSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> bloom::settings::BloomPrefilterSettings;
}
"#]
)]




pub struct LuaBloomPrefilterSettings{
    
    
        threshold:f32,


    
        threshold_softness:f32,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bloom::settings::BloomCompositeMode",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> bloom::settings::BloomCompositeMode;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &bloom::settings::BloomCompositeMode) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaBloomCompositeMode{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="clear_color::ClearColorConfig",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> clear_color::ClearColorConfig;
}
"#]
)]




pub struct LuaClearColorConfig{
    
}

    
/// A [`Resource`] that stores the color that is used to clear the screen between frames.

/// This color appears as the "background" color for simple apps,

/// when there are portions of the screen with nothing rendered.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="clear_color::ClearColor",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> clear_color::ClearColor;
}
"#]
)]



pub struct LuaClearColor(
    
    
        #[lua(output(proxy))]bevy_render::color::Color,


    
    
);

    
/// Applies a contrast adaptive sharpening (CAS) filter to the camera.

/// CAS is usually used in combination with shader based anti-aliasing methods

/// such as FXAA or TAA to regain some of the lost detail from the blurring that they introduce.

/// CAS is designed to adjust the amount of sharpening applied to different areas of an image

/// based on the local contrast. This can help avoid over-sharpening areas with high contrast

/// and under-sharpening areas with low contrast.

/// To use this, add the [`ContrastAdaptiveSharpeningSettings`] component to a 2D or 3D camera.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings;
}
"#]
)]




pub struct LuaContrastAdaptiveSharpeningSettings{
    
    
        enabled:bool,


    
        sharpening_strength:f32,


    
        denoise:bool,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="contrast_adaptive_sharpening::DenoiseCAS",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> contrast_adaptive_sharpening::DenoiseCAS;
}
"#]
)]



pub struct LuaDenoiseCAS(
    
    
        bool,


    
    
);

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="core_2d::camera_2d::Camera2d",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> core_2d::camera_2d::Camera2d;
}
"#]
)]




pub struct LuaCamera2d{
    
    
        #[lua(output(proxy))]clear_color:clear_color::ClearColorConfig,


    
    
}

    
/// Configuration for the "main 3d render graph".


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="core_3d::camera_3d::Camera3d",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> core_3d::camera_3d::Camera3d;
}
"#]
)]




pub struct LuaCamera3d{
    
    
        #[lua(output(proxy))]clear_color:clear_color::ClearColorConfig,


    
        #[lua(output(proxy))]depth_load_op:core_3d::camera_3d::Camera3dDepthLoadOp,


    
        #[lua(output(proxy))]depth_texture_usages:core_3d::camera_3d::Camera3dDepthTextureUsage,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="core_3d::camera_3d::Camera3dDepthTextureUsage",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> core_3d::camera_3d::Camera3dDepthTextureUsage;
}
"#]
)]



pub struct LuaCamera3dDepthTextureUsage(
    
    
        u32,


    
    
);

    
/// The depth clear operation to perform for the main 3d pass.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="core_3d::camera_3d::Camera3dDepthLoadOp",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> core_3d::camera_3d::Camera3dDepthLoadOp;
}
"#]
)]




pub struct LuaCamera3dDepthLoadOp{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="fxaa::Sensitivity",
functions[r#"
#[lua(kind = "Method")]
    fn get_str(&self) -> &str;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> fxaa::Sensitivity;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &fxaa::Sensitivity) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaSensitivity{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="fxaa::Fxaa",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> fxaa::Fxaa;
}
"#]
)]




pub struct LuaFxaa{
    
    
        enabled:bool,


    
        #[lua(output(proxy))]edge_threshold:fxaa::Sensitivity,


    
        #[lua(output(proxy))]edge_threshold_min:fxaa::Sensitivity,


    
    
}

    
/// If added to a [`crate::prelude::Camera3d`] then depth values will be copied to a separate texture available to the main pass.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="prepass::DepthPrepass",
functions[]
)]




pub struct LuaDepthPrepass{
    
    
    
}

    
/// If added to a [`crate::prelude::Camera3d`] then vertex world normals will be copied to a separate texture available to the main pass.

/// Normals will have normal map textures already applied.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="prepass::NormalPrepass",
functions[]
)]




pub struct LuaNormalPrepass{
    
    
    
}

    
/// If added to a [`crate::prelude::Camera3d`] then screen space motion vectors will be copied to a separate texture available to the main pass.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="prepass::MotionVectorPrepass",
functions[]
)]




pub struct LuaMotionVectorPrepass{
    
    
    
}

    
/// Component to apply temporal anti-aliasing to a 3D perspective camera.

/// Temporal anti-aliasing (TAA) is a form of image smoothing/filtering, like

/// multisample anti-aliasing (MSAA), or fast approximate anti-aliasing (FXAA).

/// TAA works by blending (averaging) each frame with the past few frames.

/// # Tradeoffs

/// Pros:

/// * Cost scales with screen/view resolution, unlike MSAA which scales with number of triangles

/// * Filters more types of aliasing than MSAA, such as textures and singular bright pixels

/// * Greatly increases the quality of stochastic rendering techniques such as SSAO, shadow mapping, etc

/// Cons:

/// * Chance of "ghosting" - ghostly trails left behind moving objects

/// * Thin geometry, lighting detail, or texture lines may flicker or disappear

/// * Slightly blurs the image, leading to a softer look (using an additional sharpening pass can reduce this)

/// Because TAA blends past frames with the current frame, when the frames differ too much

/// (such as with fast moving objects or camera cuts), ghosting artifacts may occur.

/// Artifacts tend to be reduced at higher framerates and rendering resolution.

/// # Usage Notes

/// Requires that you add [`TemporalAntiAliasPlugin`] to your app,

/// and add the [`DepthPrepass`], [`MotionVectorPrepass`], and [`TemporalJitter`]

/// components to your camera.

/// Cannot be used with [`bevy_render::camera::OrthographicProjection`].

/// Currently does not support skinned meshes and morph targets.

/// There will probably be ghosting artifacts if used with them.

/// Does not work well with alpha-blended meshes as it requires depth writing to determine motion.

/// It is very important that correct motion vectors are written for everything on screen.

/// Failure to do so will lead to ghosting artifacts. For instance, if particle effects

/// are added using a third party library, the library must either:

/// 1. Write particle motion vectors to the motion vectors prepass texture

/// 2. Render particles after TAA

/// If no [`MipBias`] component is attached to the camera, TAA will add a MipBias(-1.0) component.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="taa::TemporalAntiAliasSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> taa::TemporalAntiAliasSettings;
}
"#]
)]




pub struct LuaTemporalAntiAliasSettings{
    
    
        reset:bool,


    
    
}

    
/// Optionally enables a tonemapping shader that attempts to map linear input stimulus into a perceptually uniform image for a given [`Camera`] entity.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="tonemapping::Tonemapping",
functions[r#"
#[lua(kind = "Method")]
    fn is_enabled(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> tonemapping::Tonemapping;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &tonemapping::Tonemapping) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaTonemapping{
    
}

    
/// Enables a debanding shader that applies dithering to mitigate color banding in the final image for a given [`Camera`] entity.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="tonemapping::DebandDither",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> tonemapping::DebandDither;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &tonemapping::DebandDither) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaDebandDither{
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyCorePipelineAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyCorePipelineAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyCorePipelineAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaBloomSettings>()
                
            
                .process_type::<LuaBloomPrefilterSettings>()
                
            
                .process_type::<LuaBloomCompositeMode>()
                
            
                .process_type::<LuaClearColorConfig>()
                
            
                .process_type::<LuaClearColor>()
                
            
                .process_type::<LuaContrastAdaptiveSharpeningSettings>()
                
            
                .process_type::<LuaDenoiseCAS>()
                
            
                .process_type::<LuaCamera2d>()
                
            
                .process_type::<LuaCamera3d>()
                
            
                .process_type::<LuaCamera3dDepthTextureUsage>()
                
            
                .process_type::<LuaCamera3dDepthLoadOp>()
                
            
                .process_type::<LuaSensitivity>()
                
            
                .process_type::<LuaFxaa>()
                
            
                .process_type::<LuaDepthPrepass>()
                
            
                .process_type::<LuaNormalPrepass>()
                
            
                .process_type::<LuaMotionVectorPrepass>()
                
            
                .process_type::<LuaTemporalAntiAliasSettings>()
                
            
                .process_type::<LuaTonemapping>()
                
            
                .process_type::<LuaDebandDither>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<bloom::settings::BloomSettings>();
        
        app.register_foreign_lua_type::<bloom::settings::BloomPrefilterSettings>();
        
        app.register_foreign_lua_type::<bloom::settings::BloomCompositeMode>();
        
        app.register_foreign_lua_type::<clear_color::ClearColorConfig>();
        
        app.register_foreign_lua_type::<clear_color::ClearColor>();
        
        app.register_foreign_lua_type::<contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings>();
        
        app.register_foreign_lua_type::<contrast_adaptive_sharpening::DenoiseCAS>();
        
        app.register_foreign_lua_type::<core_2d::camera_2d::Camera2d>();
        
        app.register_foreign_lua_type::<core_3d::camera_3d::Camera3d>();
        
        app.register_foreign_lua_type::<core_3d::camera_3d::Camera3dDepthTextureUsage>();
        
        app.register_foreign_lua_type::<core_3d::camera_3d::Camera3dDepthLoadOp>();
        
        app.register_foreign_lua_type::<fxaa::Sensitivity>();
        
        app.register_foreign_lua_type::<fxaa::Fxaa>();
        
        app.register_foreign_lua_type::<prepass::DepthPrepass>();
        
        app.register_foreign_lua_type::<prepass::NormalPrepass>();
        
        app.register_foreign_lua_type::<prepass::MotionVectorPrepass>();
        
        app.register_foreign_lua_type::<taa::TemporalAntiAliasSettings>();
        
        app.register_foreign_lua_type::<tonemapping::Tonemapping>();
        
        app.register_foreign_lua_type::<tonemapping::DebandDither>();
        
    }
}
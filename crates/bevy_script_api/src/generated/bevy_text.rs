// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text::Text",
functions[r#"
/// Returns this [`Text`] with a new [`TextAlignment`].
#[lua(kind = "Method", output(proxy))]
    fn with_alignment(self, #[proxy] alignment: text::TextAlignment) -> text::Text;
}
"#,
			r#"
/// Returns this [`Text`] with soft wrapping disabled.
/// Hard wrapping, where text contains an explicit linebreak such as the escape sequence `\n`, will still occur.
#[lua(kind = "Method", output(proxy))]
    fn with_no_wrap(self) -> text::Text;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text::Text;
}
"#]
)]




pub struct LuaText{
    
    
        sections:std::vec::Vec<text::TextSection>,


    
        #[lua(output(proxy))]alignment:text::TextAlignment,


    
        #[lua(output(proxy))]linebreak_behavior:text::BreakLineOn,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text::TextSection",
functions[r#"
/// Create an empty [`TextSection`] from a style. Useful when the value will be set dynamically.
#[lua(kind = "Function", output(proxy))]
    fn from_style(#[proxy] style: text::TextStyle) -> text::TextSection;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text::TextSection;
}
"#]
)]




pub struct LuaTextSection{
    
    
        #[lua(output(proxy))]value:std::string::String,


    
        #[lua(output(proxy))]style:text::TextStyle,


    
    
}

    
/// Describes horizontal alignment preference for positioning & bounds.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text::TextAlignment",
functions[r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text::TextAlignment;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &text::TextAlignment) -> bool;
}
"#]
)]




pub struct LuaTextAlignment{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text::TextStyle",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text::TextStyle;
}
"#]
)]




pub struct LuaTextStyle{
    
    
        font:bevy_asset::Handle<font::Font>,


    
        font_size:f32,


    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
    
}

    
/// Determines how lines will be broken when preventing text from running out of bounds.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text::BreakLineOn",
functions[r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text::BreakLineOn;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &text::BreakLineOn) -> bool;
}
"#]
)]




pub struct LuaBreakLineOn{
    
}

    
/// The maximum width and height of text. The text will wrap according to the specified size.

/// Characters out of the bounds after wrapping will be truncated. Text is aligned according to the

/// specified [`TextAlignment`](crate::text::TextAlignment).

/// Note: only characters that are completely out of the bounds will be truncated, so this is not a

/// reliable limit if it is necessary to contain the text strictly in the bounds. Currently this

/// component is mainly useful for text wrapping only.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="text2d::Text2dBounds",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> text2d::Text2dBounds;
}
"#]
)]




pub struct LuaText2dBounds{
    
    
        #[lua(output(proxy))]size:bevy_math::Vec2,


    
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
                instances.add_instance("LuaTextSection", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTextSection>::new)?;
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyTextAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyTextAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyTextAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaText>()
                
            
                .process_type::<LuaTextSection>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTextSection>>()
                
            
                .process_type::<LuaTextAlignment>()
                
            
                .process_type::<LuaTextStyle>()
                
            
                .process_type::<LuaBreakLineOn>()
                
            
                .process_type::<LuaText2dBounds>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<text::Text>();
        
        app.register_foreign_lua_type::<text::TextSection>();
        
        app.register_foreign_lua_type::<text::TextAlignment>();
        
        app.register_foreign_lua_type::<text::TextStyle>();
        
        app.register_foreign_lua_type::<text::BreakLineOn>();
        
        app.register_foreign_lua_type::<text2d::Text2dBounds>();
        
    }
}
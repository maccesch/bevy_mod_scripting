// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// A [2d material](Material2d) that renders [2d meshes](crate::Mesh2dHandle) with a texture tinted by a uniform color


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="mesh2d::color_material::ColorMaterial",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> mesh2d::color_material::ColorMaterial;
}
"#]
)]




pub struct LuaColorMaterial{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
    
}

    
/// Component for rendering with meshes in the 2d pipeline, usually with a [2d material](crate::Material2d) such as [`ColorMaterial`](crate::ColorMaterial).

/// It wraps a [`Handle<Mesh>`] to differentiate from the 3d pipelines which use the handles directly as components


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="mesh2d::mesh::Mesh2dHandle",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> mesh2d::mesh::Mesh2dHandle;
}
"#]
)]



pub struct LuaMesh2dHandle(
    
    
        bevy_asset::Handle<bevy_render::mesh::Mesh>,


    
    
);

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="sprite::Sprite",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> sprite::Sprite;
}
"#]
)]




pub struct LuaSprite{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        flip_x:bool,


    
        flip_y:bool,


    
        custom_size:std::option::Option<bevy_math::Vec2>,


    
        rect:std::option::Option<bevy_math::Rect>,


    
        #[lua(output(proxy))]anchor:sprite::Anchor,


    
    
}

    
/// How a sprite is positioned relative to its [`Transform`](bevy_transform::components::Transform).

/// It defaults to `Anchor::Center`.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="sprite::Anchor",
functions[r#"
#[lua(kind = "Method", output(proxy))]
    fn as_vec(&self) -> bevy_math::Vec2;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> sprite::Anchor;
}
"#]
)]




pub struct LuaAnchor{
    
}

    
/// An atlas containing multiple textures (like a spritesheet or a tilemap).

/// [Example usage animating sprite.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/sprite_sheet.rs)

/// [Example usage loading sprite sheet.](https://github.com/bevyengine/bevy/blob/latest/examples/2d/texture_atlas.rs)


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="texture_atlas::TextureAtlas",
functions[r#"
/// Add a sprite to the list of textures in the [`TextureAtlas`]
/// returns an index to the texture which can be used with [`TextureAtlasSprite`]
/// # Arguments
/// * `rect` - The section of the atlas that contains the texture to be added,
/// from the top-left corner of the texture to the bottom-right corner
#[lua(kind = "Method")]
    fn add_texture(&mut self, #[proxy] rect: bevy_math::Rect) -> usize;
}
"#,
			r#"
/// The number of textures in the [`TextureAtlas`]
#[lua(kind = "Method")]
    fn len(&self) -> usize;
}
"#,
			r#"
/// Returns `true` if there are no textures in the [`TextureAtlas`]
#[lua(kind = "Method")]
    fn is_empty(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> texture_atlas::TextureAtlas;
}
"#]
)]




pub struct LuaTextureAtlas{
    
    
        texture:bevy_asset::Handle<bevy_render::texture::Image>,


    
        #[lua(output(proxy))]size:bevy_math::Vec2,


    
        textures:std::vec::Vec<bevy_math::Rect>,


    
        texture_handles:std::option::Option<bevy_utils::hashbrown::HashMap<bevy_asset::Handle<bevy_render::texture::Image>, usize>>,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="texture_atlas::TextureAtlasSprite",
functions[r#"
/// Create a new [`TextureAtlasSprite`] with a sprite index,
/// it should be valid in the corresponding [`TextureAtlas`]
#[lua(kind = "Function", output(proxy))]
    fn new(index: usize) -> texture_atlas::TextureAtlasSprite;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> texture_atlas::TextureAtlasSprite;
}
"#]
)]




pub struct LuaTextureAtlasSprite{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        index:usize,


    
        flip_x:bool,


    
        flip_y:bool,


    
        custom_size:std::option::Option<bevy_math::Vec2>,


    
        #[lua(output(proxy))]anchor:sprite::Anchor,


    
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaTextureAtlasSprite", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTextureAtlasSprite>::new)?;
            
        
        Ok(())
    }
}

pub struct BevySpriteAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevySpriteAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevySpriteAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaColorMaterial>()
                
            
                .process_type::<LuaMesh2dHandle>()
                
            
                .process_type::<LuaSprite>()
                
            
                .process_type::<LuaAnchor>()
                
            
                .process_type::<LuaTextureAtlas>()
                
            
                .process_type::<LuaTextureAtlasSprite>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTextureAtlasSprite>>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<mesh2d::color_material::ColorMaterial>();
        
        app.register_foreign_lua_type::<mesh2d::mesh::Mesh2dHandle>();
        
        app.register_foreign_lua_type::<sprite::Sprite>();
        
        app.register_foreign_lua_type::<sprite::Anchor>();
        
        app.register_foreign_lua_type::<texture_atlas::TextureAtlas>();
        
        app.register_foreign_lua_type::<texture_atlas::TextureAtlasSprite>();
        
    }
}
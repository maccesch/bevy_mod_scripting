// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// Controls whether an entity should rendered in wireframe-mode if the [`WireframePlugin`] is enabled


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="wireframe::Wireframe",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> wireframe::Wireframe;
}
"#]
)]




pub struct LuaWireframe{
    
    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="wireframe::WireframeConfig",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> wireframe::WireframeConfig;
}
"#]
)]




pub struct LuaWireframeConfig{
    
    
        global:bool,


    
    
}

    
/// Sets how a material's base color alpha channel is used for transparency.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="alpha::AlphaMode",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> alpha::AlphaMode;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &alpha::AlphaMode) -> bool;
}
"#]
)]




pub struct LuaAlphaMode{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bundle::CubemapVisibleEntities",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> bundle::CubemapVisibleEntities;
}
"#]
)]




pub struct LuaCubemapVisibleEntities{
    
    
        data:[bevy_render::view::VisibleEntities; 6],


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bundle::CascadesVisibleEntities",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> bundle::CascadesVisibleEntities;
}
"#]
)]




pub struct LuaCascadesVisibleEntities{
    
    
        entities:bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, std::vec::Vec<bevy_render::view::VisibleEntities>>,


    
    
}

    
/// Environment map based ambient lighting representing light from distant scenery.

/// When added to a 3D camera, this component adds indirect light

/// to every point of the scene (including inside, enclosed areas) based on

/// an environment cubemap texture. This is similar to [`crate::AmbientLight`], but

/// higher quality, and is intended for outdoor scenes.

/// The environment map must be prefiltered into a diffuse and specular cubemap based on the

/// [split-sum approximation](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf).

/// To prefilter your environment map, you can use `KhronosGroup`'s [glTF-IBL-Sampler](https://github.com/KhronosGroup/glTF-IBL-Sampler).

/// The diffuse map uses the Lambertian distribution, and the specular map uses the GGX distribution.

/// `KhronosGroup` also has several prefiltered environment maps that can be found [here](https://github.com/KhronosGroup/glTF-Sample-Environments).


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="environment_map::EnvironmentMapLight",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> environment_map::EnvironmentMapLight;
}
"#]
)]




pub struct LuaEnvironmentMapLight{
    
    
        diffuse_map:bevy_asset::Handle<bevy_render::texture::Image>,


    
        specular_map:bevy_asset::Handle<bevy_render::texture::Image>,


    
    
}

    
/// Configures the “classic” computer graphics [distance fog](https://en.wikipedia.org/wiki/Distance_fog) effect,

/// in which objects appear progressively more covered in atmospheric haze the further away they are from the camera.

/// Affects meshes rendered via the PBR [`StandardMaterial`](crate::StandardMaterial).

/// ## Falloff

/// The rate at which fog intensity increases with distance is controlled by the falloff mode.

/// Currently, the following fog falloff modes are supported:

/// - [`FogFalloff::Linear`]

/// - [`FogFalloff::Exponential`]

/// - [`FogFalloff::ExponentialSquared`]

/// - [`FogFalloff::Atmospheric`]

/// ## Example

/// ```

/// # use bevy_ecs::prelude::*;

/// # use bevy_render::prelude::*;

/// # use bevy_core_pipeline::prelude::*;

/// # use bevy_pbr::prelude::*;

/// # fn system(mut commands: Commands) {

/// commands.spawn((

///     // Setup your camera as usual

///     Camera3dBundle {

///         // ... camera options

/// #       ..Default::default()

///     },

///     // Add fog to the same entity

///     FogSettings {

///         color: Color::WHITE,

///         falloff: FogFalloff::Exponential { density: 1e-3 },

///         ..Default::default()

///     },

/// ));

/// # }

/// # bevy_ecs::system::assert_is_system(system);

/// ```

/// ## Material Override

/// Once enabled for a specific camera, the fog effect can also be disabled for individual

/// [`StandardMaterial`](crate::StandardMaterial) instances via the `fog_enabled` flag.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="fog::FogSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> fog::FogSettings;
}
"#]
)]




pub struct LuaFogSettings{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        #[lua(output(proxy))]directional_light_color:bevy_render::color::Color,


    
        directional_light_exponent:f32,


    
        #[lua(output(proxy))]falloff:fog::FogFalloff,


    
    
}

    
/// Allows switching between different fog falloff modes, and configuring their parameters.

/// ## Convenience Methods

/// When using non-linear fog modes it can be hard to determine the right parameter values

/// for a given scene.

/// For easier artistic control, instead of creating the enum variants directly, you can use the

/// visibility-based convenience methods:

/// - For `FogFalloff::Exponential`:

///     - [`FogFalloff::from_visibility()`]

///     - [`FogFalloff::from_visibility_contrast()`]

/// - For `FogFalloff::ExponentialSquared`:

///     - [`FogFalloff::from_visibility_squared()`]

///     - [`FogFalloff::from_visibility_contrast_squared()`]

/// - For `FogFalloff::Atmospheric`:

///     - [`FogFalloff::from_visibility_color()`]

///     - [`FogFalloff::from_visibility_colors()`]

///     - [`FogFalloff::from_visibility_contrast_color()`]

///     - [`FogFalloff::from_visibility_contrast_colors()`]


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="fog::FogFalloff",
functions[r#"
/// Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
/// using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
#[lua(kind = "Function", output(proxy))]
    fn from_visibility(visibility: f32) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
/// and a given contrast threshold in the range of `0.0` to `1.0`.
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast(
        visibility: f32,
        contrast_threshold: f32,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
/// using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_squared(visibility: f32) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
/// and a given contrast threshold in the range of `0.0` to `1.0`.
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_squared(
        visibility: f32,
        contrast_threshold: f32,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// and a shared color for both extinction and inscattering, using the revised Koschmieder contrast threshold,
/// [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_color(
        visibility: f32,
        #[proxy]
        extinction_inscattering_color: bevy_render::color::Color,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// extinction and inscattering colors, using the revised Koschmieder contrast threshold,
/// [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
/// ## Tips
/// - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
/// - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
/// - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_colors(
        visibility: f32,
        #[proxy]
        extinction_color: bevy_render::color::Color,
        #[proxy]
        inscattering_color: bevy_render::color::Color,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// a contrast threshold in the range of `0.0` to `1.0`, and a shared color for both extinction and inscattering.
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_color(
        visibility: f32,
        contrast_threshold: f32,
        #[proxy]
        extinction_inscattering_color: bevy_render::color::Color,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// a contrast threshold in the range of `0.0` to `1.0`, extinction and inscattering colors.
/// ## Tips
/// - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
/// - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
/// - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.
#[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_colors(
        visibility: f32,
        contrast_threshold: f32,
        #[proxy]
        extinction_color: bevy_render::color::Color,
        #[proxy]
        inscattering_color: bevy_render::color::Color,
    ) -> fog::FogFalloff;
}
"#,
			r#"
/// Calculates the extinction coefficient β, from V and Cₜ, where:
/// - Cₜ is the contrast threshold, in the range of `0.0` to `1.0`
/// - V is the visibility distance in which a perfectly black object is still identifiable
///   against the horizon sky within the contrast threshold
/// We start with Koschmieder's equation:
/// ```text
///       -ln(Cₜ)
///  V = ─────────
///          β
/// ```
/// Multiplying both sides by β/V, that gives us:
/// ```text
///       -ln(Cₜ)
///  β = ─────────
///          V
/// ```
/// See:
/// - <https://en.wikipedia.org/wiki/Visibility>
/// - <https://www.biral.com/wp-content/uploads/2015/02/Introduction_to_visibility-v2-2.pdf>
#[lua(kind = "Function")]
    fn koschmieder(v: f32, c_t: f32) -> f32;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> fog::FogFalloff;
}
"#]
)]




pub struct LuaFogFalloff{
    
}

    
/// A light that emits light in all directions from a central point.

/// Real-world values for `intensity` (luminous power in lumens) based on the electrical power

/// consumption of the type of real-world light are:

/// | Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts |

/// |------|-----|----|--------|-------|

/// | 200  | 25  |    | 3-5    | 3     |

/// | 450  | 40  | 29 | 9-11   | 5-8   |

/// | 800  | 60  |    | 13-15  | 8-12  |

/// | 1100 | 75  | 53 | 18-20  | 10-16 |

/// | 1600 | 100 | 72 | 24-28  | 14-17 |

/// | 2400 | 150 |    | 30-52  | 24-30 |

/// | 3100 | 200 |    | 49-75  | 32    |

/// | 4000 | 300 |    | 75-100 | 40.5  |

/// Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::PointLight",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::PointLight;
}
"#]
)]




pub struct LuaPointLight{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        intensity:f32,


    
        range:f32,


    
        radius:f32,


    
        shadows_enabled:bool,


    
        shadow_depth_bias:f32,


    
        shadow_normal_bias:f32,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::PointLightShadowMap",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::PointLightShadowMap;
}
"#]
)]




pub struct LuaPointLightShadowMap{
    
    
        size:usize,


    
    
}

    
/// A light that emits light in a given direction from a central point.

/// Behaves like a point light in a perfectly absorbent housing that

/// shines light only in a given direction. The direction is taken from

/// the transform, and can be specified with [`Transform::looking_at`](bevy_transform::components::Transform::looking_at).


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::SpotLight",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::SpotLight;
}
"#]
)]




pub struct LuaSpotLight{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        intensity:f32,


    
        range:f32,


    
        radius:f32,


    
        shadows_enabled:bool,


    
        shadow_depth_bias:f32,


    
        shadow_normal_bias:f32,


    
        outer_angle:f32,


    
        inner_angle:f32,


    
    
}

    
/// A Directional light.

/// Directional lights don't exist in reality but they are a good

/// approximation for light sources VERY far away, like the sun or

/// the moon.

/// The light shines along the forward direction of the entity's transform. With a default transform

/// this would be along the negative-Z axis.

/// Valid values for `illuminance` are:

/// | Illuminance (lux) | Surfaces illuminated by                        |

/// |-------------------|------------------------------------------------|

/// | 0.0001            | Moonless, overcast night sky (starlight)       |

/// | 0.002             | Moonless clear night sky with airglow          |

/// | 0.05–0.3          | Full moon on a clear night                     |

/// | 3.4               | Dark limit of civil twilight under a clear sky |

/// | 20–50             | Public areas with dark surroundings            |

/// | 50                | Family living room lights                      |

/// | 80                | Office building hallway/toilet lighting        |

/// | 100               | Very dark overcast day                         |

/// | 150               | Train station platforms                        |

/// | 320–500           | Office lighting                                |

/// | 400               | Sunrise or sunset on a clear day.              |

/// | 1000              | Overcast day; typical TV studio lighting       |

/// | 10,000–25,000     | Full daylight (not direct sun)                 |

/// | 32,000–100,000    | Direct sunlight                                |

/// Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)

/// ## Shadows

/// To enable shadows, set the `shadows_enabled` property to `true`.

/// Shadows are produced via [cascaded shadow maps](https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf).

/// To modify the cascade set up, such as the number of cascades or the maximum shadow distance,

/// change the [`CascadeShadowConfig`] component of the [`crate::bundle::DirectionalLightBundle`].

/// To control the resolution of the shadow maps, use the [`DirectionalLightShadowMap`] resource:

/// ```

/// # use bevy_app::prelude::*;

/// # use bevy_pbr::DirectionalLightShadowMap;

/// App::new()

///     .insert_resource(DirectionalLightShadowMap { size: 2048 });

/// ```


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::DirectionalLight",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::DirectionalLight;
}
"#]
)]




pub struct LuaDirectionalLight{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        illuminance:f32,


    
        shadows_enabled:bool,


    
        shadow_depth_bias:f32,


    
        shadow_normal_bias:f32,


    
    
}

    
/// Controls the resolution of [`DirectionalLight`] shadow maps.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::DirectionalLightShadowMap",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::DirectionalLightShadowMap;
}
"#]
)]




pub struct LuaDirectionalLightShadowMap{
    
    
        size:usize,


    
    
}

    
/// Controls how cascaded shadow mapping works.

/// Prefer using [`CascadeShadowConfigBuilder`] to construct an instance.

/// ```

/// # use bevy_pbr::CascadeShadowConfig;

/// # use bevy_pbr::CascadeShadowConfigBuilder;

/// # use bevy_utils::default;

/// #

/// let config: CascadeShadowConfig = CascadeShadowConfigBuilder {

///   maximum_distance: 100.0,

///   ..default()

/// }.into();

/// ```


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::CascadeShadowConfig",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::CascadeShadowConfig;
}
"#]
)]




pub struct LuaCascadeShadowConfig{
    
    
        bounds:std::vec::Vec<f32>,


    
        overlap_proportion:f32,


    
        minimum_distance:f32,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::Cascades",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::Cascades;
}
"#]
)]




pub struct LuaCascades{
    
    
        cascades:bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, std::vec::Vec<light::Cascade>>,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::Cascade",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::Cascade;
}
"#]
)]




pub struct LuaCascade{
    
    
        #[lua(output(proxy))]view_transform:bevy_math::Mat4,


    
        #[lua(output(proxy))]projection:bevy_math::Mat4,


    
        #[lua(output(proxy))]view_projection:bevy_math::Mat4,


    
        texel_size:f32,


    
    
}

    
/// An ambient light, which lights the entire scene equally.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::AmbientLight",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::AmbientLight;
}
"#]
)]




pub struct LuaAmbientLight{
    
    
        #[lua(output(proxy))]color:bevy_render::color::Color,


    
        brightness:f32,


    
    
}

    
/// Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not cast shadows.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::NotShadowCaster",
functions[]
)]




pub struct LuaNotShadowCaster{
    
    
    
}

    
/// Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not receive shadows.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::NotShadowReceiver",
functions[]
)]




pub struct LuaNotShadowReceiver{
    
    
    
}

    
/// Configure the far z-plane mode used for the furthest depth slice for clustered forward

/// rendering


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::ClusterFarZMode",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::ClusterFarZMode;
}
"#]
)]




pub struct LuaClusterFarZMode{
    
}

    
/// Configure the depth-slicing strategy for clustered forward rendering


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::ClusterZConfig",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::ClusterZConfig;
}
"#]
)]




pub struct LuaClusterZConfig{
    
    
        first_slice_depth:f32,


    
        #[lua(output(proxy))]far_z_mode:light::ClusterFarZMode,


    
    
}

    
/// Configuration of the clustering strategy for clustered forward rendering


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="light::ClusterConfig",
functions[r#"
#[lua(kind = "Method", output(proxy))]
    fn dimensions_for_screen_size(
        &self,
        #[proxy]
        screen_size: bevy_math::UVec2,
    ) -> bevy_math::UVec3;
}
"#,
			r#"
#[lua(kind = "Method")]
    fn first_slice_depth(&self) -> f32;
}
"#,
			r#"
#[lua(kind = "Method", output(proxy))]
    fn far_z_mode(&self) -> light::ClusterFarZMode;
}
"#,
			r#"
#[lua(kind = "Method")]
    fn dynamic_resizing(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> light::ClusterConfig;
}
"#]
)]




pub struct LuaClusterConfig{
    
}

    
/// The [parallax mapping] method to use to compute depth based on the

/// material's [`depth_map`].

/// Parallax Mapping uses a depth map texture to give the illusion of depth

/// variation on a mesh surface that is geometrically flat.

/// See the `parallax_mapping.wgsl` shader code for implementation details

/// and explanation of the methods used.

/// [`depth_map`]: crate::StandardMaterial::depth_map

/// [parallax mapping]: https://en.wikipedia.org/wiki/Parallax_mapping


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="parallax::ParallaxMappingMethod",
functions[r#"
#[lua(kind = "Method")]
    fn max_steps(&self) -> u32;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> parallax::ParallaxMappingMethod;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &parallax::ParallaxMappingMethod) -> bool;
}
"#]
)]




pub struct LuaParallaxMappingMethod{
    
}

    
/// A material with "standard" properties used in PBR lighting

/// Standard property values with pictures here

/// <https://google.github.io/filament/Material%20Properties.pdf>.

/// May be created directly from a [`Color`] or an [`Image`].


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="pbr_material::StandardMaterial",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> pbr_material::StandardMaterial;
}
"#]
)]




pub struct LuaStandardMaterial{
    
    
        #[lua(output(proxy))]base_color:bevy_render::color::Color,


    
        base_color_texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        #[lua(output(proxy))]emissive:bevy_render::color::Color,


    
        emissive_texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        perceptual_roughness:f32,


    
        metallic:f32,


    
        metallic_roughness_texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        reflectance:f32,


    
        normal_map_texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        flip_normal_map_y:bool,


    
        occlusion_texture:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        double_sided:bool,


    
        cull_mode:std::option::Option<bevy_render::render_resource::Face>,


    
        unlit:bool,


    
        fog_enabled:bool,


    
        #[lua(output(proxy))]alpha_mode:alpha::AlphaMode,


    
        depth_bias:f32,


    
        depth_map:std::option::Option<bevy_asset::Handle<bevy_render::texture::Image>>,


    
        parallax_depth_scale:f32,


    
        #[lua(output(proxy))]parallax_mapping_method:parallax::ParallaxMappingMethod,


    
        max_parallax_layer_count:f32,


    
    
}

    
/// Component to apply screen space ambient occlusion to a 3d camera.

/// Screen space ambient occlusion (SSAO) approximates small-scale,

/// local occlusion of _indirect_ diffuse light between objects, based on what's visible on-screen.

/// SSAO does not apply to direct lighting, such as point or directional lights.

/// This darkens creases, e.g. on staircases, and gives nice contact shadows

/// where objects meet, giving entities a more "grounded" feel.

/// # Usage Notes

/// Requires that you add [`ScreenSpaceAmbientOcclusionPlugin`] to your app,

/// and add the [`DepthPrepass`] and [`NormalPrepass`] components to your camera.

/// It strongly recommended that you use SSAO in conjunction with

/// TAA ([`bevy_core_pipeline::experimental::taa::TemporalAntiAliasSettings`]).

/// Doing so greatly reduces SSAO noise.

/// SSAO is not supported on `WebGL2`, and is not currently supported on `WebGPU` or `DirectX12`.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ssao::ScreenSpaceAmbientOcclusionSettings",
functions[r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ssao::ScreenSpaceAmbientOcclusionSettings;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ssao::ScreenSpaceAmbientOcclusionSettings) -> bool;
}
"#]
)]




pub struct LuaScreenSpaceAmbientOcclusionSettings{
    
    
        #[lua(output(proxy))]quality_level:ssao::ScreenSpaceAmbientOcclusionQualityLevel,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ssao::ScreenSpaceAmbientOcclusionQualityLevel",
functions[r#"
#[lua(kind = "Method")]
    fn sample_counts(&self) -> (u32, u32);
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ssao::ScreenSpaceAmbientOcclusionQualityLevel;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ssao::ScreenSpaceAmbientOcclusionQualityLevel) -> bool;
}
"#]
)]




pub struct LuaScreenSpaceAmbientOcclusionQualityLevel{
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaFogFalloff", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaFogFalloff>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyPbrAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyPbrAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyPbrAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaWireframe>()
                
            
                .process_type::<LuaWireframeConfig>()
                
            
                .process_type::<LuaAlphaMode>()
                
            
                .process_type::<LuaCubemapVisibleEntities>()
                
            
                .process_type::<LuaCascadesVisibleEntities>()
                
            
                .process_type::<LuaEnvironmentMapLight>()
                
            
                .process_type::<LuaFogSettings>()
                
            
                .process_type::<LuaFogFalloff>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaFogFalloff>>()
                
            
                .process_type::<LuaPointLight>()
                
            
                .process_type::<LuaPointLightShadowMap>()
                
            
                .process_type::<LuaSpotLight>()
                
            
                .process_type::<LuaDirectionalLight>()
                
            
                .process_type::<LuaDirectionalLightShadowMap>()
                
            
                .process_type::<LuaCascadeShadowConfig>()
                
            
                .process_type::<LuaCascades>()
                
            
                .process_type::<LuaCascade>()
                
            
                .process_type::<LuaAmbientLight>()
                
            
                .process_type::<LuaNotShadowCaster>()
                
            
                .process_type::<LuaNotShadowReceiver>()
                
            
                .process_type::<LuaClusterFarZMode>()
                
            
                .process_type::<LuaClusterZConfig>()
                
            
                .process_type::<LuaClusterConfig>()
                
            
                .process_type::<LuaParallaxMappingMethod>()
                
            
                .process_type::<LuaStandardMaterial>()
                
            
                .process_type::<LuaScreenSpaceAmbientOcclusionSettings>()
                
            
                .process_type::<LuaScreenSpaceAmbientOcclusionQualityLevel>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<wireframe::Wireframe>();
        
        app.register_foreign_lua_type::<wireframe::WireframeConfig>();
        
        app.register_foreign_lua_type::<alpha::AlphaMode>();
        
        app.register_foreign_lua_type::<bundle::CubemapVisibleEntities>();
        
        app.register_foreign_lua_type::<bundle::CascadesVisibleEntities>();
        
        app.register_foreign_lua_type::<environment_map::EnvironmentMapLight>();
        
        app.register_foreign_lua_type::<fog::FogSettings>();
        
        app.register_foreign_lua_type::<fog::FogFalloff>();
        
        app.register_foreign_lua_type::<light::PointLight>();
        
        app.register_foreign_lua_type::<light::PointLightShadowMap>();
        
        app.register_foreign_lua_type::<light::SpotLight>();
        
        app.register_foreign_lua_type::<light::DirectionalLight>();
        
        app.register_foreign_lua_type::<light::DirectionalLightShadowMap>();
        
        app.register_foreign_lua_type::<light::CascadeShadowConfig>();
        
        app.register_foreign_lua_type::<light::Cascades>();
        
        app.register_foreign_lua_type::<light::Cascade>();
        
        app.register_foreign_lua_type::<light::AmbientLight>();
        
        app.register_foreign_lua_type::<light::NotShadowCaster>();
        
        app.register_foreign_lua_type::<light::NotShadowReceiver>();
        
        app.register_foreign_lua_type::<light::ClusterFarZMode>();
        
        app.register_foreign_lua_type::<light::ClusterZConfig>();
        
        app.register_foreign_lua_type::<light::ClusterConfig>();
        
        app.register_foreign_lua_type::<parallax::ParallaxMappingMethod>();
        
        app.register_foreign_lua_type::<pbr_material::StandardMaterial>();
        
        app.register_foreign_lua_type::<ssao::ScreenSpaceAmbientOcclusionSettings>();
        
        app.register_foreign_lua_type::<ssao::ScreenSpaceAmbientOcclusionQualityLevel>();
        
    }
}
// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// A Stopwatch is a struct that track elapsed time when started.

/// # Examples

/// ```

/// # use bevy_time::*;

/// use std::time::Duration;

/// let mut stopwatch = Stopwatch::new();

/// assert_eq!(stopwatch.elapsed_secs(), 0.0);

/// stopwatch.tick(Duration::from_secs_f32(1.0)); // tick one second

/// assert_eq!(stopwatch.elapsed_secs(), 1.0);

/// stopwatch.pause();

/// stopwatch.tick(Duration::from_secs_f32(1.0)); // paused stopwatches don't tick

/// assert_eq!(stopwatch.elapsed_secs(), 1.0);

/// stopwatch.reset(); // reset the stopwatch

/// assert!(stopwatch.paused());

/// assert_eq!(stopwatch.elapsed_secs(), 0.0);

/// ```


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="stopwatch::Stopwatch",
functions[r#"
/// Create a new unpaused `Stopwatch` with no elapsed time.
/// # Examples
/// ```
/// # use bevy_time::*;
/// let stopwatch = Stopwatch::new();
/// assert_eq!(stopwatch.elapsed_secs(), 0.0);
/// assert_eq!(stopwatch.paused(), false);
/// ```
#[lua(kind = "Function", output(proxy))]
    fn new() -> stopwatch::Stopwatch;
}
"#,
			r#"
/// Returns the elapsed time since the last [`reset`](Stopwatch::reset)
/// of the stopwatch.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.tick(Duration::from_secs(1));
/// assert_eq!(stopwatch.elapsed(), Duration::from_secs(1));
/// ```
/// # See Also
/// [`elapsed_secs`](Stopwatch::elapsed_secs) - if an `f32` value is desirable instead.
/// [`elapsed_secs_f64`](Stopwatch::elapsed_secs_f64) - if an `f64` is desirable instead.
#[lua(kind = "Method", output(proxy))]
    fn elapsed(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns the elapsed time since the last [`reset`](Stopwatch::reset)
/// of the stopwatch, in seconds.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.tick(Duration::from_secs(1));
/// assert_eq!(stopwatch.elapsed_secs(), 1.0);
/// ```
/// # See Also
/// [`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
/// [`elapsed_secs_f64`](Stopwatch::elapsed_secs_f64) - if an `f64` is desirable instead.
#[lua(kind = "Method")]
    fn elapsed_secs(&self) -> f32;
}
"#,
			r#"
/// Returns the elapsed time since the last [`reset`](Stopwatch::reset)
/// of the stopwatch, in seconds, as f64.
/// # See Also
/// [`elapsed`](Stopwatch::elapsed) - if a `Duration` is desirable instead.
/// [`elapsed_secs`](Stopwatch::elapsed_secs) - if an `f32` is desirable instead.
#[lua(kind = "Method")]
    fn elapsed_secs_f64(&self) -> f64;
}
"#,
			r#"
/// Sets the elapsed time of the stopwatch.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.set_elapsed(Duration::from_secs_f32(1.0));
/// assert_eq!(stopwatch.elapsed_secs(), 1.0);
/// ```
#[lua(kind = "Method")]
    fn set_elapsed(&mut self, #[proxy] time: bevy_utils::Duration) -> ();
}
"#,
			r#"
/// Pauses the stopwatch. Any call to [`tick`](Stopwatch::tick) while
/// paused will not have any effect on the elapsed time.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.pause();
/// stopwatch.tick(Duration::from_secs_f32(1.5));
/// assert!(stopwatch.paused());
/// assert_eq!(stopwatch.elapsed_secs(), 0.0);
/// ```
#[lua(kind = "Method")]
    fn pause(&mut self) -> ();
}
"#,
			r#"
/// Unpauses the stopwatch. Resume the effect of ticking on elapsed time.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.pause();
/// stopwatch.tick(Duration::from_secs_f32(1.0));
/// stopwatch.unpause();
/// stopwatch.tick(Duration::from_secs_f32(1.0));
/// assert!(!stopwatch.paused());
/// assert_eq!(stopwatch.elapsed_secs(), 1.0);
/// ```
#[lua(kind = "Method")]
    fn unpause(&mut self) -> ();
}
"#,
			r#"
/// Returns `true` if the stopwatch is paused.
/// # Examples
/// ```
/// # use bevy_time::*;
/// let mut stopwatch = Stopwatch::new();
/// assert!(!stopwatch.paused());
/// stopwatch.pause();
/// assert!(stopwatch.paused());
/// stopwatch.unpause();
/// assert!(!stopwatch.paused());
/// ```
#[lua(kind = "Method")]
    fn paused(&self) -> bool;
}
"#,
			r#"
/// Resets the stopwatch. The reset doesn't affect the paused state of the stopwatch.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut stopwatch = Stopwatch::new();
/// stopwatch.tick(Duration::from_secs_f32(1.5));
/// stopwatch.reset();
/// assert_eq!(stopwatch.elapsed_secs(), 0.0);
/// ```
#[lua(kind = "Method")]
    fn reset(&mut self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &stopwatch::Stopwatch) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> stopwatch::Stopwatch;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaStopwatch{
    
    
        #[lua(output(proxy))]elapsed:bevy_utils::Duration,


    
        paused:bool,


    
    
}

    
/// A clock that tracks how much it has advanced (and how much real time has elapsed) since

/// its previous update and since its creation.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="time::Time",
functions[r#"
/// Constructs a new `Time` instance with a specific startup `Instant`.
#[lua(kind = "Function", output(proxy))]
    fn new(#[proxy] startup: std::time::Instant) -> time::Time;
}
"#,
			r#"
/// Updates the internal time measurements.
/// Calling this method as part of your app will most likely result in inaccurate timekeeping,
/// as the `Time` resource is ordinarily managed by the [`TimePlugin`](crate::TimePlugin).
#[lua(kind = "Method")]
    fn update(&mut self) -> ();
}
"#,
			r#"
/// Updates time with a specified [`Instant`].
/// This method is provided for use in tests. Calling this method as part of your app will most
/// likely result in inaccurate timekeeping, as the `Time` resource is ordinarily managed by the
/// [`TimePlugin`](crate::TimePlugin).
/// # Examples
/// ```
/// # use bevy_time::prelude::*;
/// # use bevy_ecs::prelude::*;
/// # use bevy_utils::Duration;
/// # fn main () {
/// #     test_health_system();
/// # }
/// #[derive(Resource)]
/// struct Health {
///     // Health value between 0.0 and 1.0
///     health_value: f32,
/// }
/// fn health_system(time: Res<Time>, mut health: ResMut<Health>) {
///     // Increase health value by 0.1 per second, independent of frame rate,
///     // but not beyond 1.0
///     health.health_value = (health.health_value + 0.1 * time.delta_seconds()).min(1.0);
/// }
/// // Mock time in tests
/// fn test_health_system() {
///     let mut world = World::default();
///     let mut time = Time::default();
///     time.update();
///     world.insert_resource(time);
///     world.insert_resource(Health { health_value: 0.2 });
///     let mut schedule = Schedule::new();
///     schedule.add_systems(health_system);
///     // Simulate that 30 ms have passed
///     let mut time = world.resource_mut::<Time>();
///     let last_update = time.last_update().unwrap();
///     time.update_with_instant(last_update + Duration::from_millis(30));
///     // Run system
///     schedule.run(&mut world);
///     // Check that 0.003 has been added to the health value
///     let expected_health_value = 0.2 + 0.1 * 0.03;
///     let actual_health_value = world.resource::<Health>().health_value;
///     assert_eq!(expected_health_value, actual_health_value);
/// }
/// ```
#[lua(kind = "Method")]
    fn update_with_instant(&mut self, #[proxy] instant: std::time::Instant) -> ();
}
"#,
			r#"
/// Returns the [`Instant`] the clock was created.
/// This usually represents when the app was started.
#[lua(kind = "Method", output(proxy))]
    fn startup(&self) -> std::time::Instant;
}
"#,
			r#"
/// Returns how much time has advanced since the last [`update`](#method.update), as a [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn delta(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much time has advanced since the last [`update`](#method.update), as [`f32`] seconds.
#[lua(kind = "Method")]
    fn delta_seconds(&self) -> f32;
}
"#,
			r#"
/// Returns how much time has advanced since the last [`update`](#method.update), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn delta_seconds_f64(&self) -> f64;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup), as [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn elapsed(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup), as [`f32`] seconds.
/// **Note:** This is a monotonically increasing value. It's precision will degrade over time.
/// If you need an `f32` but that precision loss is unacceptable,
/// use [`elapsed_seconds_wrapped`](#method.elapsed_seconds_wrapped).
#[lua(kind = "Method")]
    fn elapsed_seconds(&self) -> f32;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn elapsed_seconds_f64(&self) -> f64;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn elapsed_wrapped(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`f32`] seconds.
/// This method is intended for applications (e.g. shaders) that require an [`f32`] value but
/// suffer from the gradual precision loss of [`elapsed_seconds`](#method.elapsed_seconds).
#[lua(kind = "Method")]
    fn elapsed_seconds_wrapped(&self) -> f32;
}
"#,
			r#"
/// Returns how much time has advanced since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn elapsed_seconds_wrapped_f64(&self) -> f64;
}
"#,
			r#"
/// Returns how much real time has elapsed since the last [`update`](#method.update), as a [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn raw_delta(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much real time has elapsed since the last [`update`](#method.update), as [`f32`] seconds.
#[lua(kind = "Method")]
    fn raw_delta_seconds(&self) -> f32;
}
"#,
			r#"
/// Returns how much real time has elapsed since the last [`update`](#method.update), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn raw_delta_seconds_f64(&self) -> f64;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup), as [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn raw_elapsed(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup), as [`f32`] seconds.
/// **Note:** This is a monotonically increasing value. It's precision will degrade over time.
/// If you need an `f32` but that precision loss is unacceptable,
/// use [`raw_elapsed_seconds_wrapped`](#method.raw_elapsed_seconds_wrapped).
#[lua(kind = "Method")]
    fn raw_elapsed_seconds(&self) -> f32;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn raw_elapsed_seconds_f64(&self) -> f64;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`Duration`].
#[lua(kind = "Method", output(proxy))]
    fn raw_elapsed_wrapped(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`f32`] seconds.
/// This method is intended for applications (e.g. shaders) that require an [`f32`] value but
/// suffer from the gradual precision loss of [`raw_elapsed_seconds`](#method.raw_elapsed_seconds).
#[lua(kind = "Method")]
    fn raw_elapsed_seconds_wrapped(&self) -> f32;
}
"#,
			r#"
/// Returns how much real time has elapsed since [`startup`](#method.startup) modulo
/// the [`wrap_period`](#method.wrap_period), as [`f64`] seconds.
#[lua(kind = "Method")]
    fn raw_elapsed_seconds_wrapped_f64(&self) -> f64;
}
"#,
			r#"
/// Returns the modulus used to calculate [`elapsed_wrapped`](#method.elapsed_wrapped) and
/// [`raw_elapsed_wrapped`](#method.raw_elapsed_wrapped).
/// **Note:** The default modulus is one hour.
#[lua(kind = "Method", output(proxy))]
    fn wrap_period(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Sets the modulus used to calculate [`elapsed_wrapped`](#method.elapsed_wrapped) and
/// [`raw_elapsed_wrapped`](#method.raw_elapsed_wrapped).
/// **Note:** This will not take effect until the next update.
/// # Panics
/// Panics if `wrap_period` is a zero-length duration.
#[lua(kind = "Method")]
    fn set_wrap_period(&mut self, #[proxy] wrap_period: bevy_utils::Duration) -> ();
}
"#,
			r#"
/// Returns the speed the clock advances relative to your system clock, as [`f32`].
/// This is known as "time scaling" or "time dilation" in other engines.
/// **Note:** This function will return zero when time is paused.
#[lua(kind = "Method")]
    fn relative_speed(&self) -> f32;
}
"#,
			r#"
/// Returns the speed the clock advances relative to your system clock, as [`f64`].
/// This is known as "time scaling" or "time dilation" in other engines.
/// **Note:** This function will return zero when time is paused.
#[lua(kind = "Method")]
    fn relative_speed_f64(&self) -> f64;
}
"#,
			r#"
/// Sets the speed the clock advances relative to your system clock, given as an [`f32`].
/// For example, setting this to `2.0` will make the clock advance twice as fast as your system clock.
/// **Note:** This does not affect the `raw_*` measurements.
/// # Panics
/// Panics if `ratio` is negative or not finite.
#[lua(kind = "Method")]
    fn set_relative_speed(&mut self, ratio: f32) -> ();
}
"#,
			r#"
/// Sets the speed the clock advances relative to your system clock, given as an [`f64`].
/// For example, setting this to `2.0` will make the clock advance twice as fast as your system clock.
/// **Note:** This does not affect the `raw_*` measurements.
/// # Panics
/// Panics if `ratio` is negative or not finite.
#[lua(kind = "Method")]
    fn set_relative_speed_f64(&mut self, ratio: f64) -> ();
}
"#,
			r#"
/// Stops the clock, preventing it from advancing until resumed.
/// **Note:** This does not affect the `raw_*` measurements.
#[lua(kind = "Method")]
    fn pause(&mut self) -> ();
}
"#,
			r#"
/// Resumes the clock if paused.
#[lua(kind = "Method")]
    fn unpause(&mut self) -> ();
}
"#,
			r#"
/// Returns `true` if the clock is currently paused.
#[lua(kind = "Method")]
    fn is_paused(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> time::Time;
}
"#]
)]




pub struct LuaTime{
    
    
        #[lua(output(proxy))]startup:std::time::Instant,


    
        first_update:std::option::Option<std::time::Instant>,


    
        last_update:std::option::Option<std::time::Instant>,


    
        paused:bool,


    
        relative_speed:f64,


    
        #[lua(output(proxy))]delta:bevy_utils::Duration,


    
        delta_seconds:f32,


    
        delta_seconds_f64:f64,


    
        #[lua(output(proxy))]elapsed:bevy_utils::Duration,


    
        elapsed_seconds:f32,


    
        elapsed_seconds_f64:f64,


    
        #[lua(output(proxy))]raw_delta:bevy_utils::Duration,


    
        raw_delta_seconds:f32,


    
        raw_delta_seconds_f64:f64,


    
        #[lua(output(proxy))]raw_elapsed:bevy_utils::Duration,


    
        raw_elapsed_seconds:f32,


    
        raw_elapsed_seconds_f64:f64,


    
        #[lua(output(proxy))]wrap_period:bevy_utils::Duration,


    
        #[lua(output(proxy))]elapsed_wrapped:bevy_utils::Duration,


    
        elapsed_seconds_wrapped:f32,


    
        elapsed_seconds_wrapped_f64:f64,


    
        #[lua(output(proxy))]raw_elapsed_wrapped:bevy_utils::Duration,


    
        raw_elapsed_seconds_wrapped:f32,


    
        raw_elapsed_seconds_wrapped_f64:f64,


    
    
}

    
/// Tracks elapsed time. Enters the finished state once `duration` is reached.

/// Non repeating timers will stop tracking and stay in the finished state until reset.

/// Repeating timers will only be in the finished state on each tick `duration` is reached or

/// exceeded, and can still be reset at any given point.

/// Paused timers will not have elapsed time increased.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="timer::Timer",
functions[r#"
/// Creates a new timer with a given duration.
/// See also [`Timer::from_seconds`](Timer::from_seconds).
#[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        duration: bevy_utils::Duration,
        #[proxy]
        mode: timer::TimerMode,
    ) -> timer::Timer;
}
"#,
			r#"
/// Creates a new timer with a given duration in seconds.
/// # Example
/// ```
/// # use bevy_time::*;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// ```
#[lua(kind = "Function", output(proxy))]
    fn from_seconds(duration: f32, #[proxy] mode: timer::TimerMode) -> timer::Timer;
}
"#,
			r#"
/// Returns `true` if the timer has reached its duration at least once.
/// See also [`Timer::just_finished`](Timer::just_finished).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(1.5));
/// assert!(timer.finished());
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert!(timer.finished());
/// ```
#[lua(kind = "Method")]
    fn finished(&self) -> bool;
}
"#,
			r#"
/// Returns `true` only on the tick the timer reached its duration.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(1.5));
/// assert!(timer.just_finished());
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert!(!timer.just_finished());
/// ```
#[lua(kind = "Method")]
    fn just_finished(&self) -> bool;
}
"#,
			r#"
/// Returns the time elapsed on the timer. Guaranteed to be between 0.0 and `duration`.
/// Will only equal `duration` when the timer is finished and non repeating.
/// See also [`Stopwatch::elapsed`](Stopwatch::elapsed).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.elapsed(), Duration::from_secs_f32(0.5));
/// ```
#[lua(kind = "Method", output(proxy))]
    fn elapsed(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns the time elapsed on the timer as an `f32`.
/// See also [`Timer::elapsed`](Timer::elapsed).
#[lua(kind = "Method")]
    fn elapsed_secs(&self) -> f32;
}
"#,
			r#"
/// Sets the elapsed time of the timer without any other considerations.
/// See also [`Stopwatch::set`](Stopwatch::set).
/// #
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.set_elapsed(Duration::from_secs(2));
/// assert_eq!(timer.elapsed(), Duration::from_secs(2));
/// // the timer is not finished even if the elapsed time is greater than the duration.
/// assert!(!timer.finished());
/// ```
#[lua(kind = "Method")]
    fn set_elapsed(&mut self, #[proxy] time: bevy_utils::Duration) -> ();
}
"#,
			r#"
/// Returns the duration of the timer.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let timer = Timer::new(Duration::from_secs(1), TimerMode::Once);
/// assert_eq!(timer.duration(), Duration::from_secs(1));
/// ```
#[lua(kind = "Method", output(proxy))]
    fn duration(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Sets the duration of the timer.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.5, TimerMode::Once);
/// timer.set_duration(Duration::from_secs(1));
/// assert_eq!(timer.duration(), Duration::from_secs(1));
/// ```
#[lua(kind = "Method")]
    fn set_duration(&mut self, #[proxy] duration: bevy_utils::Duration) -> ();
}
"#,
			r#"
/// Returns the mode of the timer.
/// # Examples
/// ```
/// # use bevy_time::*;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
/// assert_eq!(timer.mode(), TimerMode::Repeating);
/// ```
#[lua(kind = "Method", output(proxy))]
    fn mode(&self) -> timer::TimerMode;
}
"#,
			r#"
/// Sets the mode of the timer.
/// # Examples
/// ```
/// # use bevy_time::*;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
/// timer.set_mode(TimerMode::Once);
/// assert_eq!(timer.mode(), TimerMode::Once);
/// ```
#[lua(kind = "Method")]
    fn set_mode(&mut self, #[proxy] mode: timer::TimerMode) -> ();
}
"#,
			r#"
/// Pauses the Timer. Disables the ticking of the timer.
/// See also [`Stopwatch::pause`](Stopwatch::pause).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.pause();
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.elapsed_secs(), 0.0);
/// ```
#[lua(kind = "Method")]
    fn pause(&mut self) -> ();
}
"#,
			r#"
/// Unpauses the Timer. Resumes the ticking of the timer.
/// See also [`Stopwatch::unpause()`](Stopwatch::unpause).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.pause();
/// timer.tick(Duration::from_secs_f32(0.5));
/// timer.unpause();
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.elapsed_secs(), 0.5);
/// ```
#[lua(kind = "Method")]
    fn unpause(&mut self) -> ();
}
"#,
			r#"
/// Returns `true` if the timer is paused.
/// See also [`Stopwatch::paused`](Stopwatch::paused).
/// # Examples
/// ```
/// # use bevy_time::*;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// assert!(!timer.paused());
/// timer.pause();
/// assert!(timer.paused());
/// timer.unpause();
/// assert!(!timer.paused());
/// ```
#[lua(kind = "Method")]
    fn paused(&self) -> bool;
}
"#,
			r#"
/// Resets the timer. The reset doesn't affect the `paused` state of the timer.
/// See also [`Stopwatch::reset`](Stopwatch::reset).
/// Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(1.5));
/// timer.reset();
/// assert!(!timer.finished());
/// assert!(!timer.just_finished());
/// assert_eq!(timer.elapsed_secs(), 0.0);
/// ```
#[lua(kind = "Method")]
    fn reset(&mut self) -> ();
}
"#,
			r#"
/// Returns the percentage of the timer elapsed time (goes from 0.0 to 1.0).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.percent(), 0.25);
/// ```
#[lua(kind = "Method")]
    fn percent(&self) -> f32;
}
"#,
			r#"
/// Returns the percentage of the timer remaining time (goes from 1.0 to 0.0).
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.percent_left(), 0.75);
/// ```
#[lua(kind = "Method")]
    fn percent_left(&self) -> f32;
}
"#,
			r#"
/// Returns the remaining time in seconds
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::cmp::Ordering;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(0.5));
/// let result = timer.remaining_secs().total_cmp(&1.5);
/// assert_eq!(Ordering::Equal, result);
/// ```
#[lua(kind = "Method")]
    fn remaining_secs(&self) -> f32;
}
"#,
			r#"
/// Returns the remaining time using Duration
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(2.0, TimerMode::Once);
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.remaining(), Duration::from_secs_f32(1.5));
/// ```
#[lua(kind = "Method", output(proxy))]
    fn remaining(&self) -> bevy_utils::Duration;
}
"#,
			r#"
/// Returns the number of times a repeating timer
/// finished during the last [`tick`](Timer<T>::tick) call.
/// For non repeating-timers, this method will only ever
/// return 0 or 1.
/// # Examples
/// ```
/// # use bevy_time::*;
/// use std::time::Duration;
/// let mut timer = Timer::from_seconds(1.0, TimerMode::Repeating);
/// timer.tick(Duration::from_secs_f32(6.0));
/// assert_eq!(timer.times_finished_this_tick(), 6);
/// timer.tick(Duration::from_secs_f32(2.0));
/// assert_eq!(timer.times_finished_this_tick(), 2);
/// timer.tick(Duration::from_secs_f32(0.5));
/// assert_eq!(timer.times_finished_this_tick(), 0);
/// ```
#[lua(kind = "Method")]
    fn times_finished_this_tick(&self) -> u32;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &timer::Timer) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> timer::Timer;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaTimer{
    
    
        #[lua(output(proxy))]stopwatch:stopwatch::Stopwatch,


    
        #[lua(output(proxy))]duration:bevy_utils::Duration,


    
        #[lua(output(proxy))]mode:timer::TimerMode,


    
        finished:bool,


    
        times_finished_this_tick:u32,


    
    
}

    
/// Specifies [`Timer`] behavior.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="timer::TimerMode",
functions[r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &timer::TimerMode) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> timer::TimerMode;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaTimerMode{
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
                instances.add_instance("LuaStopwatch", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaStopwatch>::new)?;
            
         
            
                instances.add_instance("LuaTime", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTime>::new)?;
            
         
            
                instances.add_instance("LuaTimer", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTimer>::new)?;
            
         
            
        
        Ok(())
    }
}

pub struct BevyTimeAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyTimeAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyTimeAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaStopwatch>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaStopwatch>>()
                
            
                .process_type::<LuaTime>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTime>>()
                
            
                .process_type::<LuaTimer>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTimer>>()
                
            
                .process_type::<LuaTimerMode>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<stopwatch::Stopwatch>();
        
        app.register_foreign_lua_type::<time::Time>();
        
        app.register_foreign_lua_type::<timer::Timer>();
        
        app.register_foreign_lua_type::<timer::TimerMode>();
        
    }
}
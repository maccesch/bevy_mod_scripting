// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;
use std::sync::Mutex;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};

/// A unique, stable asset id.

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="handle::HandleId",
functions[r#"
/// Creates a random id for an asset of type `T`.
#[lua(kind = "Function", output(proxy))]
    fn random() -> handle::HandleId;
}
"#,
			r#"
/// Creates the default id for an asset of type `T`.
#[lua(kind = "Function", output(proxy))]
    fn default() -> handle::HandleId;
}
"#,
			r#"
/// Creates an arbitrary asset id without an explicit type bound.
#[lua(kind = "Function", output(proxy))]
    fn new(#[proxy] type_uuid: bevy_reflect::Uuid, id: u64) -> handle::HandleId;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &handle::HandleId) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> handle::HandleId;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]

pub struct LuaHandleId {}

/// An unique identifier to an asset path.

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="path::AssetPathId",
functions[r#"
/// Gets the id of the source path.
#[lua(kind = "Method", output(proxy))]
    fn source_path_id(&self) -> path::SourcePathId;
}
"#,
			r#"
/// Gets the id of the sub-asset label.
#[lua(kind = "Method", output(proxy))]
    fn label_id(&self) -> path::LabelId;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &path::AssetPathId) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> path::AssetPathId;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]

pub struct LuaAssetPathId(
    #[lua(output(proxy))] path::SourcePathId,
    #[lua(output(proxy))] path::LabelId,
);

/// An unique identifier to the source path of an asset.

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="path::SourcePathId",
functions[r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &path::SourcePathId) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> path::SourcePathId;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]

pub struct LuaSourcePathId(u64);

/// An unique identifier to a sub-asset label.

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="path::LabelId",
functions[r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &path::LabelId) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> path::LabelId;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]

pub struct LuaLabelId(u64);

bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances.add_instance(
            "LuaHandleId",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaHandleId>::new,
        )?;

        Ok(())
    }
}

pub struct BevyAssetAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyAssetAPIProvider {
    type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyAssetAPI", |tw| {
            tw.document_global_instance::<Globals>()
                .expect("Something went wrong documenting globals")
                .process_type::<LuaHandleId>()
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaHandleId>>()
                .process_type::<LuaAssetPathId>()
                .process_type::<LuaSourcePathId>()
                .process_type::<LuaLabelId>()
        }))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        app.register_foreign_lua_type::<handle::HandleId>();

        app.register_foreign_lua_type::<path::AssetPathId>();

        app.register_foreign_lua_type::<path::SourcePathId>();

        app.register_foreign_lua_type::<path::LabelId>();
    }
}

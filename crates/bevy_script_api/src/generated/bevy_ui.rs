// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// Describes what type of input interaction has occurred for a UI node.

/// This is commonly queried with a `Changed<Interaction>` filter.

/// Updated in [`ui_focus_system`].

/// If a UI node has both [`Interaction`] and [`ComputedVisibility`] components,

/// [`Interaction`] will always be [`Interaction::None`]

/// when [`ComputedVisibility::is_visible()`] is false.

/// This ensures that hidden UI nodes are not interactable,

/// and do not end up stuck in an active state if hidden at the wrong time.

/// Note that you can also control the visibility of a node using the [`Display`](crate::ui_node::Display) property,

/// which fully collapses it during layout calculations.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="focus::Interaction",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> focus::Interaction;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &focus::Interaction) -> bool;
}
"#]
)]




pub struct LuaInteraction{
    
}

    
/// A component storing the position of the mouse relative to the node, (0., 0.) being the top-left corner and (1., 1.) being the bottom-right

/// If the mouse is not over the node, the value will go beyond the range of (0., 0.) to (1., 1.)

/// A None value means that the cursor position is unknown.

/// It can be used alongside interaction to get the position of the press.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="focus::RelativeCursorPosition",
functions[r#"
/// A helper function to check if the mouse is over the node
#[lua(kind = "Method")]
    fn mouse_over(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> focus::RelativeCursorPosition;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &focus::RelativeCursorPosition) -> bool;
}
"#]
)]




pub struct LuaRelativeCursorPosition{
    
    
        normalized:std::option::Option<bevy_math::Vec2>,


    
    
}

    
/// Describes whether the node should block interactions with lower nodes


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="focus::FocusPolicy",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> focus::FocusPolicy;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &focus::FocusPolicy) -> bool;
}
"#]
)]




pub struct LuaFocusPolicy{
    
}

    
/// A type which is commonly used to define margins, paddings and borders.

/// # Examples

/// ## Margin

/// A margin is used to create space around UI elements, outside of any defined borders.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let margin = UiRect::all(Val::Auto); // Centers the UI element

/// ```

/// ## Padding

/// A padding is used to create space around UI elements, inside of any defined borders.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let padding = UiRect {

///     left: Val::Px(10.0),

///     right: Val::Px(20.0),

///     top: Val::Px(30.0),

///     bottom: Val::Px(40.0),

/// };

/// ```

/// ## Borders

/// A border is used to define the width of the border of a UI element.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let border = UiRect {

///     left: Val::Px(10.0),

///     right: Val::Px(20.0),

///     top: Val::Px(30.0),

///     bottom: Val::Px(40.0),

/// };

/// ```


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="geometry::UiRect",
functions[r#"
/// Creates a new [`UiRect`] from the values specified.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::new(
///     Val::Px(10.0),
///     Val::Px(20.0),
///     Val::Px(30.0),
///     Val::Px(40.0),
/// );
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(20.0));
/// assert_eq!(ui_rect.top, Val::Px(30.0));
/// assert_eq!(ui_rect.bottom, Val::Px(40.0));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        left: ui_node::Val,
        #[proxy]
        right: ui_node::Val,
        #[proxy]
        top: ui_node::Val,
        #[proxy]
        bottom: ui_node::Val,
    ) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where all sides have the same value.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::all(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn all(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] from the values specified in logical pixels.
/// This is a shortcut for [`UiRect::new()`], applying [`Val::Px`] to all arguments.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::px(10., 20., 30., 40.);
/// assert_eq!(ui_rect.left, Val::Px(10.));
/// assert_eq!(ui_rect.right, Val::Px(20.));
/// assert_eq!(ui_rect.top, Val::Px(30.));
/// assert_eq!(ui_rect.bottom, Val::Px(40.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn px(left: f32, right: f32, top: f32, bottom: f32) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] from the values specified in percentages.
/// This is a shortcut for [`UiRect::new()`], applying [`Val::Percent`] to all arguments.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::percent(5., 10., 2., 1.);
/// assert_eq!(ui_rect.left, Val::Percent(5.));
/// assert_eq!(ui_rect.right, Val::Percent(10.));
/// assert_eq!(ui_rect.top, Val::Percent(2.));
/// assert_eq!(ui_rect.bottom, Val::Percent(1.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn percent(left: f32, right: f32, top: f32, bottom: f32) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `left` and `right` take the given value,
/// and `top` and `bottom` set to zero `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::horizontal(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Px(0.));
/// assert_eq!(ui_rect.bottom, Val::Px(0.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn horizontal(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `top` and `bottom` take the given value,
/// and `left` and `right` are set to `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::vertical(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(0.));
/// assert_eq!(ui_rect.right, Val::Px(0.));
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn vertical(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where both `left` and `right` take the value of `horizontal`, and both `top` and `bottom` take the value of `vertical`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::axes(Val::Px(10.0), Val::Percent(15.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Percent(15.0));
/// assert_eq!(ui_rect.bottom, Val::Percent(15.0));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn axes(
        #[proxy]
        horizontal: ui_node::Val,
        #[proxy]
        vertical: ui_node::Val,
    ) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `left` takes the given value, and
/// the other fields are set to `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::left(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(0.));
/// assert_eq!(ui_rect.top, Val::Px(0.));
/// assert_eq!(ui_rect.bottom, Val::Px(0.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn left(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `right` takes the given value,
/// and the other fields are set to `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::right(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(0.));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Px(0.));
/// assert_eq!(ui_rect.bottom, Val::Px(0.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn right(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `top` takes the given value,
/// and the other fields are set to `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::top(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(0.));
/// assert_eq!(ui_rect.right, Val::Px(0.));
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::Px(0.));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn top(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
/// Creates a new [`UiRect`] where `bottom` takes the given value,
/// and the other fields are set to `Val::Px(0.)`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::bottom(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(0.));
/// assert_eq!(ui_rect.right, Val::Px(0.));
/// assert_eq!(ui_rect.top, Val::Px(0.));
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```
#[lua(kind = "Function", output(proxy))]
    fn bottom(#[proxy] value: ui_node::Val) -> geometry::UiRect;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> geometry::UiRect;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &geometry::UiRect) -> bool;
}
"#]
)]




pub struct LuaUiRect{
    
    
        #[lua(output(proxy))]left:ui_node::Val,


    
        #[lua(output(proxy))]right:ui_node::Val,


    
        #[lua(output(proxy))]top:ui_node::Val,


    
        #[lua(output(proxy))]bottom:ui_node::Val,


    
    
}

    
/// Describes the size of a UI node


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Node",
functions[r#"
/// The calculated node size as width and height in logical pixels
/// automatically calculated by [`super::layout::ui_layout_system`]
#[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy_math::Vec2;
}
"#,
			r#"
/// Returns the size of the node in physical pixels based on the given scale factor and `UiScale`.
#[lua(kind = "Method", output(proxy))]
    fn physical_size(&self, scale_factor: f64, ui_scale: f64) -> bevy_math::Vec2;
}
"#,
			r#"
/// Returns the logical pixel coordinates of the UI node, based on its [`GlobalTransform`].
#[lua(kind = "Method", output(proxy))]
    fn logical_rect(
        &self,
        #[proxy]
        transform: &bevy_transform::components::GlobalTransform,
    ) -> bevy_math::Rect;
}
"#,
			r#"
/// Returns the physical pixel coordinates of the UI node, based on its [`GlobalTransform`] and the scale factor.
#[lua(kind = "Method", output(proxy))]
    fn physical_rect(
        &self,
        #[proxy]
        transform: &bevy_transform::components::GlobalTransform,
        scale_factor: f64,
        ui_scale: f64,
    ) -> bevy_math::Rect;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Node;
}
"#]
)]




pub struct LuaNode{
    
    
        #[lua(output(proxy))]calculated_size:bevy_math::Vec2,


    
    
}

    
/// Represents the possible value types for layout properties.

/// This enum allows specifying values for various [`Style`] properties in different units,

/// such as logical pixels, percentages, or automatically determined values.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Val",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Val;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::ops::Div",
        output(proxy),
        composite = "div",
        metamethod = "Div",
    )]
    fn div(self, rhs: f32) -> ui_node::Val;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::Val) -> bool;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::ops::Mul",
        output(proxy),
        composite = "mul",
        metamethod = "Mul",
    )]
    fn mul(self, rhs: f32) -> ui_node::Val;
}
"#]
)]




pub struct LuaVal{
    
}

    
/// Describes the style of a UI container node

/// Node's can be laid out using either Flexbox or CSS Grid Layout.<br />

/// See below for general learning resources and for documentation on the individual style properties.

/// ### Flexbox

/// - [MDN: Basic Concepts of Grid Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout)

/// - [A Complete Guide To Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) by CSS Tricks. This is detailed guide with illustrations and comphrehensive written explanation of the different Flexbox properties and how they work.

/// - [Flexbox Froggy](https://flexboxfroggy.com/). An interactive tutorial/game that teaches the essential parts of Flebox in a fun engaging way.

/// ### CSS Grid

/// - [MDN: Basic Concepts of Flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

/// - [A Complete Guide To CSS Grid](https://css-tricks.com/snippets/css/complete-guide-grid/) by CSS Tricks. This is detailed guide with illustrations and comphrehensive written explanation of the different CSS Grid properties and how they work.

/// - [CSS Grid Garden](https://cssgridgarden.com/). An interactive tutorial/game that teaches the essential parts of CSS Grid in a fun engaging way.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Style",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Style;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::Style) -> bool;
}
"#]
)]




pub struct LuaStyle{
    
    
        #[lua(output(proxy))]display:ui_node::Display,


    
        #[lua(output(proxy))]position_type:ui_node::PositionType,


    
        #[lua(output(proxy))]overflow:ui_node::Overflow,


    
        #[lua(output(proxy))]direction:ui_node::Direction,


    
        #[lua(output(proxy))]left:ui_node::Val,


    
        #[lua(output(proxy))]right:ui_node::Val,


    
        #[lua(output(proxy))]top:ui_node::Val,


    
        #[lua(output(proxy))]bottom:ui_node::Val,


    
        #[lua(output(proxy))]width:ui_node::Val,


    
        #[lua(output(proxy))]height:ui_node::Val,


    
        #[lua(output(proxy))]min_width:ui_node::Val,


    
        #[lua(output(proxy))]min_height:ui_node::Val,


    
        #[lua(output(proxy))]max_width:ui_node::Val,


    
        #[lua(output(proxy))]max_height:ui_node::Val,


    
        aspect_ratio:std::option::Option<f32>,


    
        #[lua(output(proxy))]align_items:ui_node::AlignItems,


    
        #[lua(output(proxy))]justify_items:ui_node::JustifyItems,


    
        #[lua(output(proxy))]align_self:ui_node::AlignSelf,


    
        #[lua(output(proxy))]justify_self:ui_node::JustifySelf,


    
        #[lua(output(proxy))]align_content:ui_node::AlignContent,


    
        #[lua(output(proxy))]justify_content:ui_node::JustifyContent,


    
        #[lua(output(proxy))]margin:geometry::UiRect,


    
        #[lua(output(proxy))]padding:geometry::UiRect,


    
        #[lua(output(proxy))]border:geometry::UiRect,


    
        #[lua(output(proxy))]flex_direction:ui_node::FlexDirection,


    
        #[lua(output(proxy))]flex_wrap:ui_node::FlexWrap,


    
        flex_grow:f32,


    
        flex_shrink:f32,


    
        #[lua(output(proxy))]flex_basis:ui_node::Val,


    
        #[lua(output(proxy))]row_gap:ui_node::Val,


    
        #[lua(output(proxy))]column_gap:ui_node::Val,


    
        #[lua(output(proxy))]grid_auto_flow:ui_node::GridAutoFlow,


    
        grid_template_rows:std::vec::Vec<ui_node::RepeatedGridTrack>,


    
        grid_template_columns:std::vec::Vec<ui_node::RepeatedGridTrack>,


    
        grid_auto_rows:std::vec::Vec<ui_node::GridTrack>,


    
        grid_auto_columns:std::vec::Vec<ui_node::GridTrack>,


    
        #[lua(output(proxy))]grid_row:ui_node::GridPlacement,


    
        #[lua(output(proxy))]grid_column:ui_node::GridPlacement,


    
    
}

    
/// How items are aligned according to the cross axis


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::AlignItems",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::AlignItems;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::AlignItems) -> bool;
}
"#]
)]




pub struct LuaAlignItems{
    
}

    
/// How items are aligned according to the cross axis


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::JustifyItems",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::JustifyItems;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::JustifyItems) -> bool;
}
"#]
)]




pub struct LuaJustifyItems{
    
}

    
/// How this item is aligned according to the cross axis.

/// Overrides [`AlignItems`].


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::AlignSelf",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::AlignSelf;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::AlignSelf) -> bool;
}
"#]
)]




pub struct LuaAlignSelf{
    
}

    
/// How this item is aligned according to the cross axis.

/// Overrides [`AlignItems`].


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::JustifySelf",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::JustifySelf;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::JustifySelf) -> bool;
}
"#]
)]




pub struct LuaJustifySelf{
    
}

    
/// Defines how each line is aligned within the flexbox.

/// It only applies if [`FlexWrap::Wrap`] is present and if there are multiple lines of items.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::AlignContent",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::AlignContent;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::AlignContent) -> bool;
}
"#]
)]




pub struct LuaAlignContent{
    
}

    
/// Defines how items are aligned according to the main axis


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::JustifyContent",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::JustifyContent;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::JustifyContent) -> bool;
}
"#]
)]




pub struct LuaJustifyContent{
    
}

    
/// Defines the text direction

/// For example English is written LTR (left-to-right) while Arabic is written RTL (right-to-left).


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Direction",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Direction;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::Direction) -> bool;
}
"#]
)]




pub struct LuaDirection{
    
}

    
/// Whether to use a Flexbox layout model.

/// Part of the [`Style`] component.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Display",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Display;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::Display) -> bool;
}
"#]
)]




pub struct LuaDisplay{
    
}

    
/// Defines how flexbox items are ordered within a flexbox


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::FlexDirection",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::FlexDirection;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::FlexDirection) -> bool;
}
"#]
)]




pub struct LuaFlexDirection{
    
}

    
/// Whether to show or hide overflowing items


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::Overflow",
functions[r#"
/// Show overflowing items on both axes
#[lua(kind = "Function", output(proxy))]
    fn visible() -> ui_node::Overflow;
}
"#,
			r#"
/// Clip overflowing items on both axes
#[lua(kind = "Function", output(proxy))]
    fn clip() -> ui_node::Overflow;
}
"#,
			r#"
/// Clip overflowing items on the x axis
#[lua(kind = "Function", output(proxy))]
    fn clip_x() -> ui_node::Overflow;
}
"#,
			r#"
/// Clip overflowing items on the y axis
#[lua(kind = "Function", output(proxy))]
    fn clip_y() -> ui_node::Overflow;
}
"#,
			r#"
/// Overflow is visible on both axes
#[lua(kind = "Method")]
    fn is_visible(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::Overflow;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::Overflow) -> bool;
}
"#]
)]




pub struct LuaOverflow{
    
    
        #[lua(output(proxy))]x:ui_node::OverflowAxis,


    
        #[lua(output(proxy))]y:ui_node::OverflowAxis,


    
    
}

    
/// Whether to show or hide overflowing items


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::OverflowAxis",
functions[r#"
/// Overflow is visible on this axis
#[lua(kind = "Method")]
    fn is_visible(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::OverflowAxis;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::OverflowAxis) -> bool;
}
"#]
)]




pub struct LuaOverflowAxis{
    
}

    
/// The strategy used to position this node


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::PositionType",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::PositionType;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::PositionType) -> bool;
}
"#]
)]




pub struct LuaPositionType{
    
}

    
/// Defines if flexbox items appear on a single line or on multiple lines


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::FlexWrap",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::FlexWrap;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::FlexWrap) -> bool;
}
"#]
)]




pub struct LuaFlexWrap{
    
}

    
/// Controls whether grid items are placed row-wise or column-wise. And whether the sparse or dense packing algorithm is used.

/// The "dense" packing algorithm attempts to fill in holes earlier in the grid, if smaller items come up later. This may cause items to appear out-of-order, when doing so would fill in holes left by larger items.

/// Defaults to [`GridAutoFlow::Row`]

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow>


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::GridAutoFlow",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::GridAutoFlow;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::GridAutoFlow) -> bool;
}
"#]
)]




pub struct LuaGridAutoFlow{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::MinTrackSizingFunction",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::MinTrackSizingFunction;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::MinTrackSizingFunction) -> bool;
}
"#]
)]




pub struct LuaMinTrackSizingFunction{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::MaxTrackSizingFunction",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::MaxTrackSizingFunction;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::MaxTrackSizingFunction) -> bool;
}
"#]
)]




pub struct LuaMaxTrackSizingFunction{
    
}

    
/// A [`GridTrack`] is a Row or Column of a CSS Grid. This struct specifies what size the track should be.

/// See below for the different "track sizing functions" you can specify.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::GridTrack",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::GridTrack;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::GridTrack) -> bool;
}
"#]
)]




pub struct LuaGridTrack{
    
    
        #[lua(output(proxy))]min_sizing_function:ui_node::MinTrackSizingFunction,


    
        #[lua(output(proxy))]max_sizing_function:ui_node::MaxTrackSizingFunction,


    
    
}

    
/// How many times to repeat a repeated grid track

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/repeat>


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::GridTrackRepetition",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::GridTrackRepetition;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::GridTrackRepetition) -> bool;
}
"#]
)]




pub struct LuaGridTrackRepetition{
    
}

    
/// Represents a *possibly* repeated [`GridTrack`].

/// The repetition parameter can either be:

///   - The integer `1`, in which case the track is non-repeated.

///   - a `u16` count to repeat the track N times

///   - A `GridTrackRepetition::AutoFit` or `GridTrackRepetition::AutoFill`

/// Note: that in the common case you want a non-repeating track (repetition count 1), you may use the constructor methods on [`GridTrack`]

/// to create a `RepeatedGridTrack`. i.e. `GridTrack::px(10.0)` is equivalent to `RepeatedGridTrack::px(1, 10.0)`.

/// You may only use one auto-repetition per track list. And if your track list contains an auto repetition

/// then all track (in and outside of the repetition) must be fixed size (px or percent). Integer repetitions are just shorthand for writing out

/// N tracks longhand and are not subject to the same limitations.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::RepeatedGridTrack",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::RepeatedGridTrack;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::RepeatedGridTrack) -> bool;
}
"#]
)]




pub struct LuaRepeatedGridTrack{
    
    
        #[lua(output(proxy))]repetition:ui_node::GridTrackRepetition,


    
        tracks:smallvec::SmallVec<[ui_node::GridTrack; 1]>,


    
    
}

    
/// Represents the position of a grid item in a single axis.

/// There are 3 fields which may be set:

///   - `start`: which grid line the item should start at

///   - `end`: which grid line the item should end at

///   - `span`: how many tracks the item should span

/// The default `span` is 1. If neither `start` or `end` is set then the item will be placed automatically.

/// Generally, at most two fields should be set. If all three fields are specifed then `span` will be ignored. If `end` specifies an earlier

/// grid line than `start` then `end` will be ignored and the item will have a span of 1.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid>


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::GridPlacement",
functions[r#"
/// Place the grid item automatically (letting the `span` default to `1`).
#[lua(kind = "Function", output(proxy))]
    fn auto() -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item automatically, specifying how many tracks it should `span`.
#[lua(kind = "Function", output(proxy))]
    fn span(span: u16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item specifying the `start` grid line (letting the `span` default to `1`).
#[lua(kind = "Function", output(proxy))]
    fn start(start: i16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item specifying the `end` grid line (letting the `span` default to `1`).
#[lua(kind = "Function", output(proxy))]
    fn end(end: i16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item specifying the `start` grid line and how many tracks it should `span`.
#[lua(kind = "Function", output(proxy))]
    fn start_span(start: i16, span: u16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item specifying `start` and `end` grid lines (`span` will be inferred)
#[lua(kind = "Function", output(proxy))]
    fn start_end(start: i16, end: i16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Place the grid item specifying the `end` grid line and how many tracks it should `span`.
#[lua(kind = "Function", output(proxy))]
    fn end_span(end: i16, span: u16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Mutate the item, setting the `start` grid line
#[lua(kind = "Method", output(proxy))]
    fn set_start(self, start: i16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Mutate the item, setting the `end` grid line
#[lua(kind = "Method", output(proxy))]
    fn set_end(self, end: i16) -> ui_node::GridPlacement;
}
"#,
			r#"
/// Mutate the item, setting the number of tracks the item should `span`
#[lua(kind = "Method", output(proxy))]
    fn set_span(self, span: u16) -> ui_node::GridPlacement;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::GridPlacement;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &ui_node::GridPlacement) -> bool;
}
"#]
)]




pub struct LuaGridPlacement{
    
    
        start:std::option::Option<i16>,


    
        span:std::option::Option<u16>,


    
        end:std::option::Option<i16>,


    
    
}

    
/// The background color of the node

/// This serves as the "fill" color.

/// When combined with [`UiImage`], tints the provided texture.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::BackgroundColor",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::BackgroundColor;
}
"#]
)]



pub struct LuaBackgroundColor(
    
    
        #[lua(output(proxy))]bevy_render::color::Color,


    
    
);

    
/// The atlas sprite to be used in a UI Texture Atlas Node


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::UiTextureAtlasImage",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::UiTextureAtlasImage;
}
"#]
)]




pub struct LuaUiTextureAtlasImage{
    
    
        index:usize,


    
        flip_x:bool,


    
        flip_y:bool,


    
    
}

    
/// The border color of the UI node.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::BorderColor",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::BorderColor;
}
"#]
)]



pub struct LuaBorderColor(
    
    
        #[lua(output(proxy))]bevy_render::color::Color,


    
    
);

    
/// The 2D texture displayed for this UI node


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::UiImage",
functions[r#"
/// flip the image along its x-axis
#[lua(kind = "Method", output(proxy))]
    fn with_flip_x(self) -> ui_node::UiImage;
}
"#,
			r#"
/// flip the image along its y-axis
#[lua(kind = "Method", output(proxy))]
    fn with_flip_y(self) -> ui_node::UiImage;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::UiImage;
}
"#]
)]




pub struct LuaUiImage{
    
    
        texture:bevy_asset::Handle<bevy_render::texture::Image>,


    
        flip_x:bool,


    
        flip_y:bool,


    
    
}

    
/// The calculated clip of the node


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::CalculatedClip",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::CalculatedClip;
}
"#]
)]




pub struct LuaCalculatedClip{
    
    
        #[lua(output(proxy))]clip:bevy_math::Rect,


    
    
}

    
/// Indicates that this [`Node`] entity's front-to-back ordering is not controlled solely

/// by its location in the UI hierarchy. A node with a higher z-index will appear on top

/// of other nodes with a lower z-index.

/// UI nodes that have the same z-index will appear according to the order in which they

/// appear in the UI hierarchy. In such a case, the last node to be added to its parent

/// will appear in front of this parent's other children.

/// Internally, nodes with a global z-index share the stacking context of root UI nodes

/// (nodes that have no parent). Because of this, there is no difference between using

/// [`ZIndex::Local(n)`] and [`ZIndex::Global(n)`] for root nodes.

/// Nodes without this component will be treated as if they had a value of [`ZIndex::Local(0)`].


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="ui_node::ZIndex",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> ui_node::ZIndex;
}
"#]
)]




pub struct LuaZIndex{
    
}

    
/// Configuration for cameras related to UI.

/// When a [`Camera`] doesn't have the [`UiCameraConfig`] component,

/// it will display the UI by default.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera_config::UiCameraConfig",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera_config::UiCameraConfig;
}
"#]
)]




pub struct LuaUiCameraConfig{
    
    
        show_ui:bool,


    
    
}

    
/// A node with a `ContentSize` component is a node where its size

/// is based on its content.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="measurement::ContentSize",
functions[]
)]




pub struct LuaContentSize{
    
    
        measure_func:std::option::Option<taffy::node::MeasureFunc>,


    
    
}

    
/// Marker struct for buttons


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="widget::button::Button",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> widget::button::Button;
}
"#]
)]




pub struct LuaButton{
    
    
    
}

    
/// The size of the image's texture

/// This component is updated automatically by [`update_image_content_size_system`]


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="widget::image::UiImageSize",
functions[r#"
/// The size of the image's texture
#[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy_math::Vec2;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> widget::image::UiImageSize;
}
"#]
)]




pub struct LuaUiImageSize{
    
    
        #[lua(output(proxy))]size:bevy_math::Vec2,


    
    
}

    
/// Marker struct for labels


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="widget::label::Label",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> widget::label::Label;
}
"#]
)]




pub struct LuaLabel{
    
    
    
}

    
/// Text system flags

/// Used internally by [`measure_text_system`] and [`text_system`] to schedule text for processing.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="widget::text::TextFlags",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> widget::text::TextFlags;
}
"#]
)]




pub struct LuaTextFlags{
    
    
        needs_new_measure_func:bool,


    
        needs_recompute:bool,


    
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
                instances.add_instance("LuaUiRect", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaUiRect>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaOverflow", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaOverflow>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaGridPlacement", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaGridPlacement>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyUiAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyUiAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyUiAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaInteraction>()
                
            
                .process_type::<LuaRelativeCursorPosition>()
                
            
                .process_type::<LuaFocusPolicy>()
                
            
                .process_type::<LuaUiRect>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaUiRect>>()
                
            
                .process_type::<LuaNode>()
                
            
                .process_type::<LuaVal>()
                
            
                .process_type::<LuaStyle>()
                
            
                .process_type::<LuaAlignItems>()
                
            
                .process_type::<LuaJustifyItems>()
                
            
                .process_type::<LuaAlignSelf>()
                
            
                .process_type::<LuaJustifySelf>()
                
            
                .process_type::<LuaAlignContent>()
                
            
                .process_type::<LuaJustifyContent>()
                
            
                .process_type::<LuaDirection>()
                
            
                .process_type::<LuaDisplay>()
                
            
                .process_type::<LuaFlexDirection>()
                
            
                .process_type::<LuaOverflow>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaOverflow>>()
                
            
                .process_type::<LuaOverflowAxis>()
                
            
                .process_type::<LuaPositionType>()
                
            
                .process_type::<LuaFlexWrap>()
                
            
                .process_type::<LuaGridAutoFlow>()
                
            
                .process_type::<LuaMinTrackSizingFunction>()
                
            
                .process_type::<LuaMaxTrackSizingFunction>()
                
            
                .process_type::<LuaGridTrack>()
                
            
                .process_type::<LuaGridTrackRepetition>()
                
            
                .process_type::<LuaRepeatedGridTrack>()
                
            
                .process_type::<LuaGridPlacement>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaGridPlacement>>()
                
            
                .process_type::<LuaBackgroundColor>()
                
            
                .process_type::<LuaUiTextureAtlasImage>()
                
            
                .process_type::<LuaBorderColor>()
                
            
                .process_type::<LuaUiImage>()
                
            
                .process_type::<LuaCalculatedClip>()
                
            
                .process_type::<LuaZIndex>()
                
            
                .process_type::<LuaUiCameraConfig>()
                
            
                .process_type::<LuaContentSize>()
                
            
                .process_type::<LuaButton>()
                
            
                .process_type::<LuaUiImageSize>()
                
            
                .process_type::<LuaLabel>()
                
            
                .process_type::<LuaTextFlags>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<focus::Interaction>();
        
        app.register_foreign_lua_type::<focus::RelativeCursorPosition>();
        
        app.register_foreign_lua_type::<focus::FocusPolicy>();
        
        app.register_foreign_lua_type::<geometry::UiRect>();
        
        app.register_foreign_lua_type::<ui_node::Node>();
        
        app.register_foreign_lua_type::<ui_node::Val>();
        
        app.register_foreign_lua_type::<ui_node::Style>();
        
        app.register_foreign_lua_type::<ui_node::AlignItems>();
        
        app.register_foreign_lua_type::<ui_node::JustifyItems>();
        
        app.register_foreign_lua_type::<ui_node::AlignSelf>();
        
        app.register_foreign_lua_type::<ui_node::JustifySelf>();
        
        app.register_foreign_lua_type::<ui_node::AlignContent>();
        
        app.register_foreign_lua_type::<ui_node::JustifyContent>();
        
        app.register_foreign_lua_type::<ui_node::Direction>();
        
        app.register_foreign_lua_type::<ui_node::Display>();
        
        app.register_foreign_lua_type::<ui_node::FlexDirection>();
        
        app.register_foreign_lua_type::<ui_node::Overflow>();
        
        app.register_foreign_lua_type::<ui_node::OverflowAxis>();
        
        app.register_foreign_lua_type::<ui_node::PositionType>();
        
        app.register_foreign_lua_type::<ui_node::FlexWrap>();
        
        app.register_foreign_lua_type::<ui_node::GridAutoFlow>();
        
        app.register_foreign_lua_type::<ui_node::MinTrackSizingFunction>();
        
        app.register_foreign_lua_type::<ui_node::MaxTrackSizingFunction>();
        
        app.register_foreign_lua_type::<ui_node::GridTrack>();
        
        app.register_foreign_lua_type::<ui_node::GridTrackRepetition>();
        
        app.register_foreign_lua_type::<ui_node::RepeatedGridTrack>();
        
        app.register_foreign_lua_type::<ui_node::GridPlacement>();
        
        app.register_foreign_lua_type::<ui_node::BackgroundColor>();
        
        app.register_foreign_lua_type::<ui_node::UiTextureAtlasImage>();
        
        app.register_foreign_lua_type::<ui_node::BorderColor>();
        
        app.register_foreign_lua_type::<ui_node::UiImage>();
        
        app.register_foreign_lua_type::<ui_node::CalculatedClip>();
        
        app.register_foreign_lua_type::<ui_node::ZIndex>();
        
        app.register_foreign_lua_type::<camera_config::UiCameraConfig>();
        
        app.register_foreign_lua_type::<measurement::ContentSize>();
        
        app.register_foreign_lua_type::<widget::button::Button>();
        
        app.register_foreign_lua_type::<widget::image::UiImageSize>();
        
        app.register_foreign_lua_type::<widget::label::Label>();
        
        app.register_foreign_lua_type::<widget::text::TextFlags>();
        
    }
}
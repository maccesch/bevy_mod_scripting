// @generated by cargo bevy-api-gen generate, modify the templates not this file

#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// This file is generatedchange the template not this file
extern crate self as bevy_script_api;

use std::sync::Mutex;
use bevy::prelude::App;
use bevy_mod_scripting_core::prelude::*;

#[cfg(feature = "lua")]
use {
    crate::{lua::RegisterForeignLuaType, ReflectedValue},
    bevy_mod_scripting_lua::docs::LuaDocFragment,
    bevy_mod_scripting_lua_derive::LuaProxy,
};


    
/// Render viewport configuration for the [`Camera`] component.

/// The viewport defines the area on the render target to which the camera renders its image.

/// You can overlay multiple cameras in a single window using viewports to create effects like

/// split screen, minimaps, and character viewers.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::camera::Viewport",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::camera::Viewport;
}
"#]
)]




pub struct LuaViewport{
    
    
        #[lua(output(proxy))]physical_position:bevy_math::UVec2,


    
        #[lua(output(proxy))]physical_size:bevy_math::UVec2,


    
        depth:std::ops::Range<f32>,


    
    
}

    
/// The defining [`Component`] for camera entities,

/// storing information about how and what to render through this camera.

/// The [`Camera`] component is added to an entity to define the properties of the viewpoint from

/// which rendering occurs. It defines the position of the view to render, the projection method

/// to transform the 3D objects into a 2D image, as well as the render target into which that image

/// is produced.

/// Adding a camera is typically done by adding a bundle, either the `Camera2dBundle` or the

/// `Camera3dBundle`.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::camera::Camera",
functions[r#"
/// The projection matrix computed using this camera's [`CameraProjection`].
#[lua(kind = "Method", output(proxy))]
    fn projection_matrix(&self) -> bevy_math::Mat4;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::camera::Camera;
}
"#]
)]




pub struct LuaCamera{
    
    
        viewport:std::option::Option<camera::camera::Viewport>,


    
        order:isize,


    
        is_active:bool,


    
        computed:camera::camera::ComputedCameraValues,


    
        #[lua(output(proxy))]target:camera::camera::RenderTarget,


    
        hdr:bool,


    
        output_mode:camera::camera::CameraOutputMode,


    
        msaa_writeback:bool,


    
    
}

    
/// Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::camera::CameraRenderGraph",
functions[]
)]



pub struct LuaCameraRenderGraph(
    
    
        #[lua(output(proxy))]std::borrow::Cow<'static, str>,


    
    
);

    
/// The "target" that a [`Camera`] will render to. For example, this could be a [`Window`](bevy_window::Window)

/// swapchain or an [`Image`].


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::camera::RenderTarget",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::camera::RenderTarget;
}
"#]
)]




pub struct LuaRenderTarget{
    
}

    
/// Normalized version of the render target.

/// Once we have this we shouldn't need to resolve it down anymore.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::camera::NormalizedRenderTarget",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::camera::NormalizedRenderTarget;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &camera::camera::NormalizedRenderTarget) -> bool;
}
"#]
)]




pub struct LuaNormalizedRenderTarget{
    
}

    
/// A unique id that corresponds to a specific [`ManualTextureView`] in the [`ManualTextureViews`] collection.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::manual_texture_view::ManualTextureViewHandle",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::manual_texture_view::ManualTextureViewHandle;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(
        &self,
        #[proxy]
        other: &camera::manual_texture_view::ManualTextureViewHandle,
    ) -> bool;
}
"#]
)]



pub struct LuaManualTextureViewHandle(
    
    
        u32,


    
    
);

    
/// A configurable [`CameraProjection`] that can select its projection type at runtime.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::projection::Projection",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::projection::Projection;
}
"#]
)]




pub struct LuaProjection{
    
}

    
/// A 3D camera projection in which distant objects appear smaller than close objects.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::projection::PerspectiveProjection",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::projection::PerspectiveProjection;
}
"#]
)]




pub struct LuaPerspectiveProjection{
    
    
        fov:f32,


    
        aspect_ratio:f32,


    
        near:f32,


    
        far:f32,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::projection::ScalingMode",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::projection::ScalingMode;
}
"#]
)]




pub struct LuaScalingMode{
    
}

    
/// Project a 3D space onto a 2D surface using parallel lines, i.e., unlike [`PerspectiveProjection`],

/// the size of objects remains the same regardless of their distance to the camera.

/// The volume contained in the projection is called the *view frustum*. Since the viewport is rectangular

/// and projection lines are parallel, the view frustum takes the shape of a cuboid.

/// Note that the scale of the projection and the apparent size of objects are inversely proportional.

/// As the size of the projection increases, the size of objects decreases.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="camera::projection::OrthographicProjection",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> camera::projection::OrthographicProjection;
}
"#]
)]




pub struct LuaOrthographicProjection{
    
    
        near:f32,


    
        far:f32,


    
        #[lua(output(proxy))]viewport_origin:bevy_math::Vec2,


    
        #[lua(output(proxy))]scaling_mode:camera::projection::ScalingMode,


    
        scale:f32,


    
        #[lua(output(proxy))]area:bevy_math::Rect,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="color::Color",
functions[r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].
#[lua(kind = "Function", output(proxy))]
    fn rgb(r: f32, g: f32, b: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// * `a` - Alpha channel. [0.0, 1.0]
/// See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].
#[lua(kind = "Function", output(proxy))]
    fn rgba(r: f32, g: f32, b: f32, a: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` from linear RGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// See also [`Color::rgb`], [`Color::rgba_linear`].
#[lua(kind = "Function", output(proxy))]
    fn rgb_linear(r: f32, g: f32, b: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` from linear RGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// * `a` - Alpha channel. [0.0, 1.0]
/// See also [`Color::rgba`], [`Color::rgb_linear`].
#[lua(kind = "Function", output(proxy))]
    fn rgba_linear(r: f32, g: f32, b: f32, a: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` with HSL representation in sRGB colorspace.
/// # Arguments
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `saturation` - Saturation channel. [0.0, 1.0]
/// * `lightness` - Lightness channel. [0.0, 1.0]
/// See also [`Color::hsla`].
#[lua(kind = "Function", output(proxy))]
    fn hsl(hue: f32, saturation: f32, lightness: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` with HSL representation in sRGB colorspace.
/// # Arguments
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `saturation` - Saturation channel. [0.0, 1.0]
/// * `lightness` - Lightness channel. [0.0, 1.0]
/// * `alpha` - Alpha channel. [0.0, 1.0]
/// See also [`Color::hsl`].
#[lua(kind = "Function", output(proxy))]
    fn hsla(hue: f32, saturation: f32, lightness: f32, alpha: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` with LCH representation in sRGB colorspace.
/// # Arguments
/// * `lightness` - Lightness channel. [0.0, 1.5]
/// * `chroma` - Chroma channel. [0.0, 1.5]
/// * `hue` - Hue channel. [0.0, 360.0]
/// See also [`Color::lcha`].
#[lua(kind = "Function", output(proxy))]
    fn lch(lightness: f32, chroma: f32, hue: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` with LCH representation in sRGB colorspace.
/// # Arguments
/// * `lightness` - Lightness channel. [0.0, 1.5]
/// * `chroma` - Chroma channel. [0.0, 1.5]
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `alpha` - Alpha channel. [0.0, 1.0]
/// See also [`Color::lch`].
#[lua(kind = "Function", output(proxy))]
    fn lcha(lightness: f32, chroma: f32, hue: f32, alpha: f32) -> color::Color;
}
"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0, 255]
/// * `g` - Green channel. [0, 255]
/// * `b` - Blue channel. [0, 255]
/// See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].
#[lua(kind = "Function", output(proxy))]
    fn rgb_u8(r: u8, g: u8, b: u8) -> color::Color;
}
"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0, 255]
/// * `g` - Green channel. [0, 255]
/// * `b` - Blue channel. [0, 255]
/// * `a` - Alpha channel. [0, 255]
/// See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].
#[lua(kind = "Function", output(proxy))]
    fn rgba_u8(r: u8, g: u8, b: u8, a: u8) -> color::Color;
}
"#,
			r#"
/// Get red in sRGB colorspace.
#[lua(kind = "Method")]
    fn r(&self) -> f32;
}
"#,
			r#"
/// Get green in sRGB colorspace.
#[lua(kind = "Method")]
    fn g(&self) -> f32;
}
"#,
			r#"
/// Get blue in sRGB colorspace.
#[lua(kind = "Method")]
    fn b(&self) -> f32;
}
"#,
			r#"
/// Returns this color with red set to a new value in sRGB colorspace.
#[lua(kind = "Method", output(proxy))]
    fn with_r(self, r: f32) -> color::Color;
}
"#,
			r#"
/// Returns this color with green set to a new value in sRGB colorspace.
#[lua(kind = "Method", output(proxy))]
    fn with_g(self, g: f32) -> color::Color;
}
"#,
			r#"
/// Returns this color with blue set to a new value in sRGB colorspace.
#[lua(kind = "Method", output(proxy))]
    fn with_b(self, b: f32) -> color::Color;
}
"#,
			r#"
/// Get alpha.
#[lua(kind = "Method")]
    fn a(&self) -> f32;
}
"#,
			r#"
/// Returns this color with a new alpha value.
#[lua(kind = "Method", output(proxy))]
    fn with_a(self, a: f32) -> color::Color;
}
"#,
			r#"
/// Converts a `Color` to variant `Color::Rgba`
#[lua(kind = "Method", output(proxy))]
    fn as_rgba(&self) -> color::Color;
}
"#,
			r#"
/// Converts a `Color` to variant `Color::RgbaLinear`
#[lua(kind = "Method", output(proxy))]
    fn as_rgba_linear(&self) -> color::Color;
}
"#,
			r#"
/// Converts a `Color` to variant `Color::Hsla`
#[lua(kind = "Method", output(proxy))]
    fn as_hsla(&self) -> color::Color;
}
"#,
			r#"
/// Converts a `Color` to variant `Color::Lcha`
#[lua(kind = "Method", output(proxy))]
    fn as_lcha(&self) -> color::Color;
}
"#,
			r#"
/// Converts a `Color` to a `[u8; 4]` from sRGB colorspace
#[lua(kind = "Method")]
    fn as_rgba_u8(&self) -> [u8; 4];
}
"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from sRGB colorspace
#[lua(kind = "Method")]
    fn as_rgba_f32(self) -> [f32; 4];
}
"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from linear RGB colorspace
#[lua(kind = "Method")]
    fn as_linear_rgba_f32(self) -> [f32; 4];
}
"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from HSL colorspace
#[lua(kind = "Method")]
    fn as_hsla_f32(self) -> [f32; 4];
}
"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from LCH colorspace
#[lua(kind = "Method")]
    fn as_lcha_f32(self) -> [f32; 4];
}
"#,
			r#"
/// Converts `Color` to a `u32` from sRGB colorspace.
/// Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
/// `A` will be the most significant byte and `R` the least significant.
#[lua(kind = "Method")]
    fn as_rgba_u32(self) -> u32;
}
"#,
			r#"
/// Converts Color to a u32 from linear RGB colorspace.
/// Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
/// `A` will be the most significant byte and `R` the least significant.
#[lua(kind = "Method")]
    fn as_linear_rgba_u32(self) -> u32;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> color::Color;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &color::Color) -> bool;
}
"#]
)]




pub struct LuaColor{
    
}

    
/// Contains global values useful when writing shaders.

/// Currently only contains values related to time.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="globals::GlobalsUniform",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> globals::GlobalsUniform;
}
"#]
)]




pub struct LuaGlobalsUniform{
    
    
        time:f32,


    
        delta_time:f32,


    
        frame_count:u32,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="mesh::mesh::skinning::SkinnedMesh",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> mesh::mesh::skinning::SkinnedMesh;
}
"#]
)]




pub struct LuaSkinnedMesh{
    
    
        inverse_bindposes:bevy_asset::Handle<mesh::mesh::skinning::SkinnedMeshInverseBindposes>,


    
        joints:std::vec::Vec<bevy_ecs::entity::Entity>,


    
    
}

    
/// Controls the [morph targets] for all child [`Handle<Mesh>`] entities. In most cases, [`MorphWeights`] should be considered

/// the "source of truth" when writing morph targets for meshes. However you can choose to write child [`MeshMorphWeights`]

/// if your situation requires more granularity. Just note that if you set [`MorphWeights`], it will overwrite child

/// [`MeshMorphWeights`] values.

/// This exists because Bevy's [`Mesh`] corresponds to a _single_ surface / material, whereas morph targets

/// as defined in the GLTF spec exist on "multi-primitive meshes" (where each primitive is its own surface with its own material).

/// Therefore in Bevy [`MorphWeights`] an a parent entity are the "canonical weights" from a GLTF perspective, which then

/// synchronized to child [`Handle<Mesh>`] / [`MeshMorphWeights`] (which correspond to "primitives" / "surfaces" from a GLTF perspective).   

/// Add this to the parent of one or more [`Entities`](`Entity`) with a [`Handle<Mesh>`] with a [`MeshMorphWeights`].

/// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="mesh::morph::MorphWeights",
functions[r#"
#[lua(kind = "Method")]
    fn weights(&self) -> &[f32];
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> mesh::morph::MorphWeights;
}
"#]
)]




pub struct LuaMorphWeights{
    
    
        weights:std::vec::Vec<f32>,


    
        first_mesh:std::option::Option<bevy_asset::Handle<mesh::mesh::Mesh>>,


    
    
}

    
/// Control a specific [`Mesh`] instance's [morph targets]. These control the weights of

/// specific "mesh primitives" in scene formats like GLTF. They can be set manually, but

/// in most cases they should "automatically" synced by setting the [`MorphWeights`] component

/// on a parent entity.

/// See [`MorphWeights`] for more details on Bevy's morph target implementation.

/// Add this to an [`Entity`] with a [`Handle<Mesh>`] with a [`MorphAttributes`] set

/// to control individual weights of each morph target.

/// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="mesh::morph::MeshMorphWeights",
functions[r#"
#[lua(kind = "Method")]
    fn weights(&self) -> &[f32];
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> mesh::morph::MeshMorphWeights;
}
"#]
)]




pub struct LuaMeshMorphWeights{
    
    
        weights:std::vec::Vec<f32>,


    
    
}

    
/// An axis-aligned bounding box.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="primitives::Aabb",
functions[r#"
#[lua(kind = "Function", output(proxy))]
    fn from_min_max(
        #[proxy]
        minimum: bevy_math::Vec3,
        #[proxy]
        maximum: bevy_math::Vec3,
    ) -> primitives::Aabb;
}
"#,
			r#"
#[lua(kind = "Method", output(proxy))]
    fn min(&self) -> bevy_math::Vec3A;
}
"#,
			r#"
#[lua(kind = "Method", output(proxy))]
    fn max(&self) -> bevy_math::Vec3A;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> primitives::Aabb;
}
"#]
)]




pub struct LuaAabb{
    
    
        #[lua(output(proxy))]center:bevy_math::Vec3A,


    
        #[lua(output(proxy))]half_extents:bevy_math::Vec3A,


    
    
}

    
/// A frustum made up of the 6 defining half spaces.

/// Half spaces are ordered left, right, top, bottom, near, far.

/// The normal vectors of the half spaces point towards the interior of the frustum.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="primitives::Frustum",
functions[r#"
/// Returns a frustum derived from `view_projection`.
#[lua(kind = "Function", output(proxy))]
    fn from_view_projection(
        #[proxy]
        view_projection: &bevy_math::Mat4,
    ) -> primitives::Frustum;
}
"#,
			r#"
/// Returns a frustum derived from `view_projection`,
/// but with a custom far plane.
#[lua(kind = "Function", output(proxy))]
    fn from_view_projection_custom_far(
        #[proxy]
        view_projection: &bevy_math::Mat4,
        #[proxy]
        view_translation: &bevy_math::Vec3,
        #[proxy]
        view_backward: &bevy_math::Vec3,
        far: f32,
    ) -> primitives::Frustum;
}
"#,
			r#"
/// Returns a frustum derived from `view_projection`,
/// without a far plane.
#[lua(kind = "Function", output(proxy))]
    fn from_view_projection_no_far(
        #[proxy]
        view_projection: &bevy_math::Mat4,
    ) -> primitives::Frustum;
}
"#,
			r#"
/// Checks if an Oriented Bounding Box (obb) intersects the frustum.
#[lua(kind = "Method")]
    fn intersects_obb(
        &self,
        #[proxy]
        aabb: &primitives::Aabb,
        #[proxy]
        model_to_world: &bevy_math::Mat4,
        intersect_near: bool,
        intersect_far: bool,
    ) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> primitives::Frustum;
}
"#]
)]




pub struct LuaFrustum{
    
    
        half_spaces:[primitives::HalfSpace; 6],


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="primitives::CubemapFrusta",
functions[]
)]




pub struct LuaCubemapFrusta{
    
    
        frusta:[primitives::Frustum; 6],


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="primitives::CascadesFrusta",
functions[]
)]




pub struct LuaCascadesFrusta{
    
    
        frusta:bevy_utils::hashbrown::HashMap<bevy_ecs::entity::Entity, std::vec::Vec<primitives::Frustum>>,


    
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="texture::image::Image",
functions[r#"
/// Returns the aspect ratio (height/width) of a 2D image.
#[lua(kind = "Method")]
    fn aspect_2d(&self) -> f32;
}
"#,
			r#"
/// Returns the size of a 2D image.
#[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy_math::Vec2;
}
"#,
			r#"
/// Takes a 2D image containing vertically stacked images of the same size, and reinterprets
/// it as a 2D array texture, where each of the stacked images becomes one layer of the
/// array. This is primarily for use with the `texture2DArray` shader uniform type.
/// # Panics
/// Panics if the texture is not 2D, has more than one layers or is not evenly dividable into
/// the `layers`.
#[lua(kind = "Method")]
    fn reinterpret_stacked_2d_as_array(&mut self, layers: u32) -> ();
}
"#,
			r#"
/// Whether the texture format is compressed or uncompressed
#[lua(kind = "Method")]
    fn is_compressed(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> texture::image::Image;
}
"#]
)]




pub struct LuaImage{
    
    
        data:std::vec::Vec<u8>,


    
        texture_descriptor:wgpu_types::TextureDescriptor<std::option::Option<&'static str>, &'static [wgpu::TextureFormat]>,


    
        sampler_descriptor:texture::image::ImageSampler,


    
        texture_view_descriptor:std::option::Option<wgpu::TextureViewDescriptor<'static>>,


    
    
}

    
/// Describes which rendering layers an entity belongs to.

/// Cameras with this component will only render entities with intersecting

/// layers.

/// There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may

/// belong to one or more layers, or no layer at all.

/// The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.

/// An entity with this component without any layers is invisible.

/// Entities without this component belong to layer `0`.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::render_layers::RenderLayers",
functions[r#"
/// Create a new `RenderLayers` belonging to the given layer.
#[lua(kind = "Function", output(proxy))]
    fn layer(n: u8) -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
/// Create a new `RenderLayers` that belongs to all layers.
#[lua(kind = "Function", output(proxy))]
    fn all() -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
/// Create a new `RenderLayers` that belongs to no layers.
#[lua(kind = "Function", output(proxy))]
    fn none() -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
/// Add the given layer.
/// This may be called multiple times to allow an entity to belong
/// to multiple rendering layers. The maximum layer is `TOTAL_LAYERS - 1`.
/// # Panics
/// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.
#[lua(kind = "Method", output(proxy))]
    fn with(self, layer: u8) -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
/// Removes the given rendering layer.
/// # Panics
/// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.
#[lua(kind = "Method", output(proxy))]
    fn without(self, layer: u8) -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
/// Determine if a `RenderLayers` intersects another.
/// `RenderLayers`s intersect if they share any common layers.
/// A `RenderLayers` with no layers will not match any other
/// `RenderLayers`, even another with no layers.
#[lua(kind = "Method")]
    fn intersects(
        &self,
        #[proxy]
        other: &view::visibility::render_layers::RenderLayers,
    ) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::visibility::render_layers::RenderLayers;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &view::visibility::render_layers::RenderLayers) -> bool;
}
"#]
)]



pub struct LuaRenderLayers(
    
    
        u32,


    
    
);

    
/// User indication of whether an entity is visible. Propagates down the entity hierarchy.

/// If an entity is hidden in this way, all [`Children`] (and all of their children and so on) who

/// are set to [`Inherited`](Self::Inherited) will also be hidden.

/// This is done by the `visibility_propagate_system` which uses the entity hierarchy and

/// `Visibility` to set the values of each entity's [`ComputedVisibility`] component.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::Visibility",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::visibility::Visibility;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#]
)]




pub struct LuaVisibility{
    
}

    

#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::ComputedVisibilityFlags",
functions[r#"
/// Get a flags value with all bits unset.
#[lua(kind = "Function", output(proxy))]
    fn empty() -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// Get a flags value with all known bits set.
#[lua(kind = "Function", output(proxy))]
    fn all() -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// Get the underlying bits value.
/// The returned value is exactly the bits set in this flags value.
#[lua(kind = "Method")]
    fn bits(&self) -> u8;
}
"#,
			r#"
/// Convert from a bits value, unsetting any unknown bits.
#[lua(kind = "Function", output(proxy))]
    fn from_bits_truncate(bits: u8) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// Convert from a bits value exactly.
#[lua(kind = "Function", output(proxy))]
    fn from_bits_retain(bits: u8) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// Whether all bits in this flags value are unset.
#[lua(kind = "Method")]
    fn is_empty(&self) -> bool;
}
"#,
			r#"
/// Whether all known bits in this flags value are set.
#[lua(kind = "Method")]
    fn is_all(&self) -> bool;
}
"#,
			r#"
/// Whether any set bits in a source flags value are also set in a target flags value.
#[lua(kind = "Method")]
    fn intersects(
        &self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> bool;
}
"#,
			r#"
/// Whether all set bits in a source flags value are also set in a target flags value.
#[lua(kind = "Method")]
    fn contains(
        &self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> bool;
}
"#,
			r#"
/// The bitwise or (`|`) of the bits in two flags values.
#[lua(kind = "Method")]
    fn insert(
        &mut self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> ();
}
"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `remove` won't truncate `other`, but the `!` operator will.
#[lua(kind = "Method")]
    fn remove(
        &mut self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> ();
}
"#,
			r#"
/// The bitwise exclusive-or (`^`) of the bits in two flags values.
#[lua(kind = "Method")]
    fn toggle(
        &mut self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> ();
}
"#,
			r#"
/// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
#[lua(kind = "Method")]
    fn set(
        &mut self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
        value: bool,
    ) -> ();
}
"#,
			r#"
/// The bitwise and (`&`) of the bits in two flags values.
#[lua(kind = "Method", output(proxy))]
    fn intersection(
        self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// The bitwise or (`|`) of the bits in two flags values.
#[lua(kind = "Method", output(proxy))]
    fn union(
        self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `difference` won't truncate `other`, but the `!` operator will.
#[lua(kind = "Method", output(proxy))]
    fn difference(
        self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// The bitwise exclusive-or (`^`) of the bits in two flags values.
#[lua(kind = "Method", output(proxy))]
    fn symmetric_difference(
        self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
#[lua(kind = "Method", output(proxy))]
    fn complement(self) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `difference` won't truncate `other`, but the `!` operator will.
#[lua(
        kind = "Method",
        as_trait = "std::ops::Sub",
        output(proxy),
        composite = "sub",
        metamethod = "Sub",
    )]
    fn sub(
        self,
        #[proxy]
        other: view::visibility::ComputedVisibilityFlags,
    ) -> view::visibility::ComputedVisibilityFlags;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &view::visibility::ComputedVisibilityFlags) -> bool;
}
"#]
)]



pub struct LuaComputedVisibilityFlags(
    
    
        <view::visibility::ComputedVisibilityFlags as bitflags::__private::PublicFlags>::Internal,


    
    
);

    
/// Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::ComputedVisibility",
functions[r#"
/// Whether this entity is visible to something this frame. This is true if and only if [`Self::is_visible_in_hierarchy`] and [`Self::is_visible_in_view`]
/// are true. This is the canonical method to call to determine if an entity should be drawn.
/// This value is updated in [`PostUpdate`] by the [`VisibilitySystems::CheckVisibility`] system set.
/// Reading it during [`Update`](bevy_app::Update) will yield the value from the previous frame.
#[lua(kind = "Method")]
    fn is_visible(&self) -> bool;
}
"#,
			r#"
/// Whether this entity is visible in the entity hierarchy, which is determined by the [`Visibility`] component.
/// This takes into account "visibility inheritance". If any of this entity's ancestors (see [`Parent`]) are hidden, this entity
/// will be hidden as well. This value is updated in the [`VisibilitySystems::VisibilityPropagate`], which lives in the [`PostUpdate`] schedule.
#[lua(kind = "Method")]
    fn is_visible_in_hierarchy(&self) -> bool;
}
"#,
			r#"
/// Whether this entity is visible in _any_ view (Cameras, Lights, etc). Each entity type (and view type) should choose how to set this
/// value. For cameras and drawn entities, this will take into account [`RenderLayers`].
/// This value is reset to `false` every frame in [`VisibilitySystems::VisibilityPropagate`] during [`PostUpdate`].
/// Each entity type then chooses how to set this field in the [`VisibilitySystems::CheckVisibility`] system set, in [`PostUpdate`].
/// Meshes might use frustum culling to decide if they are visible in a view.
/// Other entities might just set this to `true` every frame.
#[lua(kind = "Method")]
    fn is_visible_in_view(&self) -> bool;
}
"#,
			r#"
/// Sets `is_visible_in_view` to `true`. This is not reversible for a given frame, as it encodes whether or not this is visible in
/// _any_ view. This will be automatically reset to `false` every frame in [`VisibilitySystems::VisibilityPropagate`] and then set
/// to the proper value in [`VisibilitySystems::CheckVisibility`]. This should _only_ be set in systems with the [`VisibilitySystems::CheckVisibility`]
/// label. Don't call this unless you are defining a custom visibility system. For normal user-defined entity visibility, see [`Visibility`].
#[lua(kind = "Method")]
    fn set_visible_in_view(&mut self) -> ();
}
"#,
			r#"
#[lua(kind = "Method")]
    fn reset(&mut self, visible_in_hierarchy: bool) -> ();
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::visibility::ComputedVisibility;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::cmp::Eq")]
    fn assert_receiver_is_total_eq(&self) -> ();
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &view::visibility::ComputedVisibility) -> bool;
}
"#]
)]




pub struct LuaComputedVisibility{
    
    
        #[lua(output(proxy))]flags:view::visibility::ComputedVisibilityFlags,


    
    
}

    
/// Use this component to opt-out of built-in frustum culling for Mesh entities


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::NoFrustumCulling",
functions[]
)]




pub struct LuaNoFrustumCulling{
    
    
    
}

    
/// Collection of entities visible from the current view.

/// This component contains all entities which are visible from the currently

/// rendered view. The collection is updated automatically by the [`check_visibility()`]

/// system, and renderers can use it to optimize rendering of a particular view, to

/// prevent drawing items not visible from that view.

/// This component is intended to be attached to the same entity as the [`Camera`] and

/// the [`Frustum`] defining the view.

/// Currently this component is ignored by the sprite renderer, so sprite rendering

/// is not optimized per view.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::visibility::VisibleEntities",
functions[r#"
#[lua(kind = "Method")]
    fn len(&self) -> usize;
}
"#,
			r#"
#[lua(kind = "Method")]
    fn is_empty(&self) -> bool;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::visibility::VisibleEntities;
}
"#]
)]




pub struct LuaVisibleEntities{
    
    
        entities:std::vec::Vec<bevy_ecs::entity::Entity>,


    
    
}

    
/// Configuration resource for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing).

/// The number of samples to run for Multi-Sample Anti-Aliasing. Higher numbers result in

/// smoother edges.

/// Defaults to 4 samples.

/// Note that web currently only supports 1 or 4 samples.

/// # Example

/// ```

/// # use bevy_app::prelude::App;

/// # use bevy_render::prelude::Msaa;

/// App::new()

///     .insert_resource(Msaa::default())

///     .run();

/// ```


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::Msaa",
functions[r#"
#[lua(kind = "Method")]
    fn samples(&self) -> u32;
}
"#,
			r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::Msaa;
}
"#,
			r#"
#[lua(
        kind = "Method",
        as_trait = "std::cmp::PartialEq",
        composite = "eq",
        metamethod = "Eq",
    )]
    fn eq(&self, #[proxy] other: &view::Msaa) -> bool;
}
"#]
)]




pub struct LuaMsaa{
    
}

    
/// Configures basic color grading parameters to adjust the image appearance. Grading is applied just before/after tonemapping for a given [`Camera`](crate::camera::Camera) entity.


#[derive(LuaProxy)]
#[proxy(
derive(clone,debug),
remote="view::ColorGrading",
functions[r#"
#[lua(kind = "Method", as_trait = "std::clone::Clone", output(proxy))]
    fn clone(&self) -> view::ColorGrading;
}
"#]
)]




pub struct LuaColorGrading{
    
    
        exposure:f32,


    
        gamma:f32,


    
        pre_saturation:f32,


    
        post_saturation:f32,


    
    
}


bevy_script_api::util::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaColor", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaColor>::new)?;
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaAabb", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaAabb>::new)?;
            
         
            
                instances.add_instance("LuaFrustum", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaFrustum>::new)?;
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaRenderLayers", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaRenderLayers>::new)?;
            
         
            
         
            
                instances.add_instance("LuaComputedVisibilityFlags", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaComputedVisibilityFlags>::new)?;
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyRenderAPIProvider;

impl bevy_mod_scripting::core::hosts::APIProvider for BevyRenderAPIProvider {
        type APITarget = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(LuaDocFragment::new("BevyRenderAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaViewport>()
                
            
                .process_type::<LuaCamera>()
                
            
                .process_type::<LuaCameraRenderGraph>()
                
            
                .process_type::<LuaRenderTarget>()
                
            
                .process_type::<LuaNormalizedRenderTarget>()
                
            
                .process_type::<LuaManualTextureViewHandle>()
                
            
                .process_type::<LuaProjection>()
                
            
                .process_type::<LuaPerspectiveProjection>()
                
            
                .process_type::<LuaScalingMode>()
                
            
                .process_type::<LuaOrthographicProjection>()
                
            
                .process_type::<LuaColor>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaColor>>()
                
            
                .process_type::<LuaGlobalsUniform>()
                
            
                .process_type::<LuaSkinnedMesh>()
                
            
                .process_type::<LuaMorphWeights>()
                
            
                .process_type::<LuaMeshMorphWeights>()
                
            
                .process_type::<LuaAabb>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaAabb>>()
                
            
                .process_type::<LuaFrustum>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaFrustum>>()
                
            
                .process_type::<LuaCubemapFrusta>()
                
            
                .process_type::<LuaCascadesFrusta>()
                
            
                .process_type::<LuaImage>()
                
            
                .process_type::<LuaRenderLayers>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaRenderLayers>>()
                
            
                .process_type::<LuaVisibility>()
                
            
                .process_type::<LuaComputedVisibilityFlags>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaComputedVisibilityFlags>>()
                
            
                .process_type::<LuaComputedVisibility>()
                
            
                .process_type::<LuaNoFrustumCulling>()
                
            
                .process_type::<LuaVisibleEntities>()
                
            
                .process_type::<LuaMsaa>()
                
            
                .process_type::<LuaColorGrading>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut App) {
        
        app.register_foreign_lua_type::<camera::camera::Viewport>();
        
        app.register_foreign_lua_type::<camera::camera::Camera>();
        
        app.register_foreign_lua_type::<camera::camera::CameraRenderGraph>();
        
        app.register_foreign_lua_type::<camera::camera::RenderTarget>();
        
        app.register_foreign_lua_type::<camera::camera::NormalizedRenderTarget>();
        
        app.register_foreign_lua_type::<camera::manual_texture_view::ManualTextureViewHandle>();
        
        app.register_foreign_lua_type::<camera::projection::Projection>();
        
        app.register_foreign_lua_type::<camera::projection::PerspectiveProjection>();
        
        app.register_foreign_lua_type::<camera::projection::ScalingMode>();
        
        app.register_foreign_lua_type::<camera::projection::OrthographicProjection>();
        
        app.register_foreign_lua_type::<color::Color>();
        
        app.register_foreign_lua_type::<globals::GlobalsUniform>();
        
        app.register_foreign_lua_type::<mesh::mesh::skinning::SkinnedMesh>();
        
        app.register_foreign_lua_type::<mesh::morph::MorphWeights>();
        
        app.register_foreign_lua_type::<mesh::morph::MeshMorphWeights>();
        
        app.register_foreign_lua_type::<primitives::Aabb>();
        
        app.register_foreign_lua_type::<primitives::Frustum>();
        
        app.register_foreign_lua_type::<primitives::CubemapFrusta>();
        
        app.register_foreign_lua_type::<primitives::CascadesFrusta>();
        
        app.register_foreign_lua_type::<texture::image::Image>();
        
        app.register_foreign_lua_type::<view::visibility::render_layers::RenderLayers>();
        
        app.register_foreign_lua_type::<view::visibility::Visibility>();
        
        app.register_foreign_lua_type::<view::visibility::ComputedVisibilityFlags>();
        
        app.register_foreign_lua_type::<view::visibility::ComputedVisibility>();
        
        app.register_foreign_lua_type::<view::visibility::NoFrustumCulling>();
        
        app.register_foreign_lua_type::<view::visibility::VisibleEntities>();
        
        app.register_foreign_lua_type::<view::Msaa>();
        
        app.register_foreign_lua_type::<view::ColorGrading>();
        
    }
}
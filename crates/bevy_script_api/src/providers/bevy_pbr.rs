#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file

use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_render::*;

use super::bevy_time::*;

use super::bevy_transform::*;

use super::bevy_core_pipeline::*;

extern crate self as bevy_script_api;

/// Enables wireframe rendering for any entity it is attached to.

/// It will ignore the [`WireframeConfig`] global setting.

/// This requires the [`WireframePlugin`] to be enabled.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::wireframe::Wireframe",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::wireframe::Wireframe;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &wireframe::Wireframe) -> bool;

"#]
)]

pub struct LuaWireframe {}

/// Sets the color of the [`Wireframe`] of the entity it is attached to.

/// If this component is present but there's no [`Wireframe`] component,

/// it will still affect the color of the wireframe when [`WireframeConfig::global`] is set to true.

/// This overrides the [`WireframeConfig::default_color`].

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::wireframe::WireframeColor",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::wireframe::WireframeColor;

"#]
)]

pub struct LuaWireframeColor {}

/// Disables wireframe rendering for any entity it is attached to.

/// It will ignore the [`WireframeConfig`] global setting.

/// This requires the [`WireframePlugin`] to be enabled.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::wireframe::NoWireframe",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::wireframe::NoWireframe;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &wireframe::NoWireframe) -> bool;

"#]
)]

pub struct LuaNoWireframe {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::wireframe::WireframeConfig",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::wireframe::WireframeConfig;

"#]
)]

pub struct LuaWireframeConfig {}

/// Sets how a material's base color alpha channel is used for transparency.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::AlphaMode",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::AlphaMode;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &alpha::AlphaMode) -> bool;

"#]
)]

pub struct LuaAlphaMode {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::CubemapVisibleEntities",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::CubemapVisibleEntities;

"#]
)]

pub struct LuaCubemapVisibleEntities {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::CascadesVisibleEntities",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::CascadesVisibleEntities;

"#]
)]

pub struct LuaCascadesVisibleEntities {}

/// Configures the “classic” computer graphics [distance fog](https://en.wikipedia.org/wiki/Distance_fog) effect,

/// in which objects appear progressively more covered in atmospheric haze the further away they are from the camera.

/// Affects meshes rendered via the PBR [`StandardMaterial`](crate::StandardMaterial).

/// ## Falloff

/// The rate at which fog intensity increases with distance is controlled by the falloff mode.

/// Currently, the following fog falloff modes are supported:

/// - [`FogFalloff::Linear`]

/// - [`FogFalloff::Exponential`]

/// - [`FogFalloff::ExponentialSquared`]

/// - [`FogFalloff::Atmospheric`]

/// ## Example

/// ```

/// # use bevy_ecs::prelude::*;

/// # use bevy_render::prelude::*;

/// # use bevy_core_pipeline::prelude::*;

/// # use bevy_pbr::prelude::*;

/// # fn system(mut commands: Commands) {

/// commands.spawn((

///     // Setup your camera as usual

///     Camera3dBundle {

///         // ... camera options

/// #       ..Default::default()

///     },

///     // Add fog to the same entity

///     FogSettings {

///         color: Color::WHITE,

///         falloff: FogFalloff::Exponential { density: 1e-3 },

///         ..Default::default()

///     },

/// ));

/// # }

/// # bevy_ecs::system::assert_is_system(system);

/// ```

/// ## Material Override

/// Once enabled for a specific camera, the fog effect can also be disabled for individual

/// [`StandardMaterial`](crate::StandardMaterial) instances via the `fog_enabled` flag.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::FogSettings",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::FogSettings;

"#]
)]

pub struct LuaFogSettings {}

/// Allows switching between different fog falloff modes, and configuring their parameters.

/// ## Convenience Methods

/// When using non-linear fog modes it can be hard to determine the right parameter values

/// for a given scene.

/// For easier artistic control, instead of creating the enum variants directly, you can use the

/// visibility-based convenience methods:

/// - For `FogFalloff::Exponential`:

///     - [`FogFalloff::from_visibility()`]

///     - [`FogFalloff::from_visibility_contrast()`]

/// - For `FogFalloff::ExponentialSquared`:

///     - [`FogFalloff::from_visibility_squared()`]

///     - [`FogFalloff::from_visibility_contrast_squared()`]

/// - For `FogFalloff::Atmospheric`:

///     - [`FogFalloff::from_visibility_color()`]

///     - [`FogFalloff::from_visibility_colors()`]

///     - [`FogFalloff::from_visibility_contrast_color()`]

///     - [`FogFalloff::from_visibility_contrast_colors()`]

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::FogFalloff",
functions[r#"
/// Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
/// using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility(visibility: f32) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::Exponential`] value from the given visibility distance in world units,
/// and a given contrast threshold in the range of `0.0` to `1.0`.

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast(
        visibility: f32,
        contrast_threshold: f32,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
/// using the revised Koschmieder contrast threshold, [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_squared(visibility: f32) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::ExponentialSquared`] value from the given visibility distance in world units,
/// and a given contrast threshold in the range of `0.0` to `1.0`.

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_squared(
        visibility: f32,
        contrast_threshold: f32,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// and a shared color for both extinction and inscattering, using the revised Koschmieder contrast threshold,
/// [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_color(
        visibility: f32,
        #[proxy]
        extinction_inscattering_color: bevy::render::color::Color,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// extinction and inscattering colors, using the revised Koschmieder contrast threshold,
/// [`FogFalloff::REVISED_KOSCHMIEDER_CONTRAST_THRESHOLD`].
/// ## Tips
/// - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
/// - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
/// - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_colors(
        visibility: f32,
        #[proxy]
        extinction_color: bevy::render::color::Color,
        #[proxy]
        inscattering_color: bevy::render::color::Color,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// a contrast threshold in the range of `0.0` to `1.0`, and a shared color for both extinction and inscattering.

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_color(
        visibility: f32,
        contrast_threshold: f32,
        #[proxy]
        extinction_inscattering_color: bevy::render::color::Color,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Creates a [`FogFalloff::Atmospheric`] value from the given visibility distance in world units,
/// a contrast threshold in the range of `0.0` to `1.0`, extinction and inscattering colors.
/// ## Tips
/// - Alpha values of the provided colors can modulate the `extinction` and `inscattering` effects;
/// - Using an `extinction_color` of [`Color::WHITE`] or [`Color::NONE`] disables the extinction effect;
/// - Using an `inscattering_color` of [`Color::BLACK`] or [`Color::NONE`] disables the inscattering effect.

    #[lua(kind = "Function", output(proxy))]
    fn from_visibility_contrast_colors(
        visibility: f32,
        contrast_threshold: f32,
        #[proxy]
        extinction_color: bevy::render::color::Color,
        #[proxy]
        inscattering_color: bevy::render::color::Color,
    ) -> bevy::pbr::prelude::FogFalloff;

"#,
			r#"
/// Calculates the extinction coefficient β, from V and Cₜ, where:
/// - Cₜ is the contrast threshold, in the range of `0.0` to `1.0`
/// - V is the visibility distance in which a perfectly black object is still identifiable
///   against the horizon sky within the contrast threshold
/// We start with Koschmieder's equation:
/// ```text
///       -ln(Cₜ)
///  V = ─────────
///          β
/// ```
/// Multiplying both sides by β/V, that gives us:
/// ```text
///       -ln(Cₜ)
///  β = ─────────
///          V
/// ```
/// See:
/// - <https://en.wikipedia.org/wiki/Visibility>
/// - <https://www.biral.com/wp-content/uploads/2015/02/Introduction_to_visibility-v2-2.pdf>

    #[lua(kind = "Function")]
    fn koschmieder(v: f32, c_t: f32) -> f32;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::FogFalloff;

"#]
)]

pub struct LuaFogFalloff {}

/// A light that emits light in all directions from a central point.

/// Real-world values for `intensity` (luminous power in lumens) based on the electrical power

/// consumption of the type of real-world light are:

/// | Luminous Power (lumen) (i.e. the intensity member) | Incandescent non-halogen (Watts) | Incandescent halogen (Watts) | Compact fluorescent (Watts) | LED (Watts |

/// |------|-----|----|--------|-------|

/// | 200  | 25  |    | 3-5    | 3     |

/// | 450  | 40  | 29 | 9-11   | 5-8   |

/// | 800  | 60  |    | 13-15  | 8-12  |

/// | 1100 | 75  | 53 | 18-20  | 10-16 |

/// | 1600 | 100 | 72 | 24-28  | 14-17 |

/// | 2400 | 150 |    | 30-52  | 24-30 |

/// | 3100 | 200 |    | 49-75  | 32    |

/// | 4000 | 300 |    | 75-100 | 40.5  |

/// Source: [Wikipedia](https://en.wikipedia.org/wiki/Lumen_(unit)#Lighting)

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::PointLight",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::PointLight;

"#]
)]

pub struct LuaPointLight {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::PointLightShadowMap",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::PointLightShadowMap;

"#]
)]

pub struct LuaPointLightShadowMap {}

/// A light that emits light in a given direction from a central point.

/// Behaves like a point light in a perfectly absorbent housing that

/// shines light only in a given direction. The direction is taken from

/// the transform, and can be specified with [`Transform::looking_at`](Transform::looking_at).

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::SpotLight",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::SpotLight;

"#]
)]

pub struct LuaSpotLight {}

/// A Directional light.

/// Directional lights don't exist in reality but they are a good

/// approximation for light sources VERY far away, like the sun or

/// the moon.

/// The light shines along the forward direction of the entity's transform. With a default transform

/// this would be along the negative-Z axis.

/// Valid values for `illuminance` are:

/// | Illuminance (lux) | Surfaces illuminated by                        |

/// |-------------------|------------------------------------------------|

/// | 0.0001            | Moonless, overcast night sky (starlight)       |

/// | 0.002             | Moonless clear night sky with airglow          |

/// | 0.05–0.3          | Full moon on a clear night                     |

/// | 3.4               | Dark limit of civil twilight under a clear sky |

/// | 20–50             | Public areas with dark surroundings            |

/// | 50                | Family living room lights                      |

/// | 80                | Office building hallway/toilet lighting        |

/// | 100               | Very dark overcast day                         |

/// | 150               | Train station platforms                        |

/// | 320–500           | Office lighting                                |

/// | 400               | Sunrise or sunset on a clear day.              |

/// | 1000              | Overcast day; typical TV studio lighting       |

/// | 10,000–25,000     | Full daylight (not direct sun)                 |

/// | 32,000–100,000    | Direct sunlight                                |

/// Source: [Wikipedia](https://en.wikipedia.org/wiki/Lux)

/// ## Shadows

/// To enable shadows, set the `shadows_enabled` property to `true`.

/// Shadows are produced via [cascaded shadow maps](https://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf).

/// To modify the cascade set up, such as the number of cascades or the maximum shadow distance,

/// change the [`CascadeShadowConfig`] component of the [`DirectionalLightBundle`].

/// To control the resolution of the shadow maps, use the [`DirectionalLightShadowMap`] resource:

/// ```

/// # use bevy_app::prelude::*;

/// # use bevy_pbr::DirectionalLightShadowMap;

/// App::new()

///     .insert_resource(DirectionalLightShadowMap { size: 2048 });

/// ```

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::DirectionalLight",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::DirectionalLight;

"#]
)]

pub struct LuaDirectionalLight {}

/// Controls the resolution of [`DirectionalLight`] shadow maps.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::DirectionalLightShadowMap",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::DirectionalLightShadowMap;

"#]
)]

pub struct LuaDirectionalLightShadowMap {}

/// Controls how cascaded shadow mapping works.

/// Prefer using [`CascadeShadowConfigBuilder`] to construct an instance.

/// ```

/// # use bevy_pbr::CascadeShadowConfig;

/// # use bevy_pbr::CascadeShadowConfigBuilder;

/// # use bevy_utils::default;

/// #

/// let config: CascadeShadowConfig = CascadeShadowConfigBuilder {

///   maximum_distance: 100.0,

///   ..default()

/// }.into();

/// ```

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::CascadeShadowConfig",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::CascadeShadowConfig;

"#]
)]

pub struct LuaCascadeShadowConfig {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::Cascades",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::Cascades;

"#]
)]

pub struct LuaCascades {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::Cascade",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::Cascade;

"#]
)]

pub struct LuaCascade {}

/// An ambient light, which lights the entire scene equally.

/// This resource is inserted by the [`PbrPlugin`] and by default it is set to a low ambient light.

/// # Examples

/// Make ambient light slightly brighter:

/// ```

/// # use bevy_ecs::system::ResMut;

/// # use bevy_pbr::AmbientLight;

/// fn setup_ambient_light(mut ambient_light: ResMut<AmbientLight>) {

///    ambient_light.brightness = 100.0;

/// }

/// ```

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::AmbientLight",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::AmbientLight;

"#]
)]

pub struct LuaAmbientLight {}

/// Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not cast shadows.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::NotShadowCaster",
functions[]
)]

pub struct LuaNotShadowCaster {}

/// Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) not receive shadows.

/// **Note:** If you're using diffuse transmission, setting [`NotShadowReceiver`] will

/// cause both “regular” shadows as well as diffusely transmitted shadows to be disabled,

/// even when [`TransmittedShadowReceiver`] is being used.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::NotShadowReceiver",
functions[]
)]

pub struct LuaNotShadowReceiver {}

/// Add this component to make a [`Mesh`](bevy_render::mesh::Mesh) using a PBR material with [`diffuse_transmission`](crate::pbr_material::StandardMaterial::diffuse_transmission)`> 0.0`

/// receive shadows on its diffuse transmission lobe. (i.e. its “backside”)

/// Not enabled by default, as it requires carefully setting up [`thickness`](crate::pbr_material::StandardMaterial::thickness)

/// (and potentially even baking a thickness texture!) to match the geometry of the mesh, in order to avoid self-shadow artifacts.

/// **Note:** Using [`NotShadowReceiver`] overrides this component.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::TransmittedShadowReceiver",
functions[]
)]

pub struct LuaTransmittedShadowReceiver {}

/// Add this component to a [`Camera3d`](bevy_core_pipeline::core_3d::Camera3d)

/// to control how to anti-alias shadow edges.

/// The different modes use different approaches to

/// [Percentage Closer Filtering](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing).

/// Currently does not affect point lights.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ShadowFilteringMethod",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ShadowFilteringMethod;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &light::ShadowFilteringMethod) -> bool;

"#]
)]

pub struct LuaShadowFilteringMethod {}

/// Configure the far z-plane mode used for the furthest depth slice for clustered forward

/// rendering

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ClusterFarZMode",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ClusterFarZMode;

"#]
)]

pub struct LuaClusterFarZMode {}

/// Configure the depth-slicing strategy for clustered forward rendering

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ClusterZConfig",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ClusterZConfig;

"#]
)]

pub struct LuaClusterZConfig {}

/// Configuration of the clustering strategy for clustered forward rendering

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ClusterConfig",
functions[r#"

    #[lua(kind = "Method", output(proxy))]
    fn dimensions_for_screen_size(
        &self,
        #[proxy]
        screen_size: bevy::math::UVec2,
    ) -> bevy::math::UVec3;

"#,
			r#"

    #[lua(kind = "Method")]
    fn first_slice_depth(&self) -> f32;

"#,
			r#"

    #[lua(kind = "Method", output(proxy))]
    fn far_z_mode(&self) -> bevy::pbr::ClusterFarZMode;

"#,
			r#"

    #[lua(kind = "Method")]
    fn dynamic_resizing(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ClusterConfig;

"#]
)]

pub struct LuaClusterConfig {}

/// A pair of cubemap textures that represent the surroundings of a specific

/// area in space.

/// See [`crate::environment_map`] for detailed information.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::EnvironmentMapLight",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::EnvironmentMapLight;

"#]
)]

pub struct LuaEnvironmentMapLight {}

/// The component that defines an irradiance volume.

/// See [`crate::irradiance_volume`] for detailed information.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::irradiance_volume::IrradianceVolume",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::irradiance_volume::IrradianceVolume;

"#]
)]

pub struct LuaIrradianceVolume {}

/// A marker component for a light probe, which is a cuboid region that provides

/// global illumination to all fragments inside it.

/// The light probe range is conceptually a unit cube (1×1×1) centered on the

/// origin.  The [`bevy_transform::prelude::Transform`] applied to this entity

/// can scale, rotate, or translate that cube so that it contains all fragments

/// that should take this light probe into account.

/// Note that a light probe will have no effect unless the entity contains some

/// kind of illumination, which can either be an [`EnvironmentMapLight`] or an

/// [`IrradianceVolume`].

/// When multiple sources of indirect illumination can be applied to a fragment,

/// the highest-quality one is chosen. Diffuse and specular illumination are

/// considered separately, so, for example, Bevy may decide to sample the

/// diffuse illumination from an irradiance volume and the specular illumination

/// from a reflection probe. From highest priority to lowest priority, the

/// ranking is as follows:

/// | Rank | Diffuse              | Specular             |

/// | ---- | -------------------- | -------------------- |

/// | 1    | Lightmap             | Lightmap             |

/// | 2    | Irradiance volume    | Reflection probe     |

/// | 3    | Reflection probe     | View environment map |

/// | 4    | View environment map |                      |

/// Note that ambient light is always added to the diffuse component and does

/// not participate in the ranking. That is, ambient light is applied in

/// addition to, not instead of, the light sources above.

/// A terminology note: Unfortunately, there is little agreement across game and

/// graphics engines as to what to call the various techniques that Bevy groups

/// under the term *light probe*. In Bevy, a *light probe* is the generic term

/// that encompasses both *reflection probes* and *irradiance volumes*. In

/// object-oriented terms, *light probe* is the superclass, and *reflection

/// probe* and *irradiance volume* are subclasses. In other engines, you may see

/// the term *light probe* refer to an irradiance volume with a single voxel, or

/// perhaps some other technique, while in Bevy *light probe* refers not to a

/// specific technique but rather to a class of techniques. Developers familiar

/// with other engines should be aware of this terminology difference.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::LightProbe",
functions[r#"
/// Creates a new light probe component.

    #[lua(kind = "Function", output(proxy))]
    fn new() -> bevy::pbr::prelude::LightProbe;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::LightProbe;

"#]
)]

pub struct LuaLightProbe {}

/// A component that applies baked indirect diffuse global illumination from a

/// lightmap.

/// When assigned to an entity that contains a [`Mesh`] and a

/// [`StandardMaterial`](crate::StandardMaterial), if the mesh has a second UV

/// layer ([`ATTRIBUTE_UV_1`](bevy_render::mesh::Mesh::ATTRIBUTE_UV_1)), then

/// the lightmap will render using those UVs.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::Lightmap",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::Lightmap;

"#]
)]

pub struct LuaLightmap {}

/// Default render method used for opaque materials.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::DefaultOpaqueRendererMethod",
functions[r#"

    #[lua(kind = "Function", output(proxy))]
    fn forward() -> bevy::pbr::DefaultOpaqueRendererMethod;

"#,
			r#"

    #[lua(kind = "Function", output(proxy))]
    fn deferred() -> bevy::pbr::DefaultOpaqueRendererMethod;

"#,
			r#"

    #[lua(kind = "Method")]
    fn set_to_forward(&mut self) -> ();

"#,
			r#"

    #[lua(kind = "Method")]
    fn set_to_deferred(&mut self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::DefaultOpaqueRendererMethod;

"#]
)]

pub struct LuaDefaultOpaqueRendererMethod();

/// Render method used for opaque materials.

/// The forward rendering main pass draws each mesh entity and shades it according to its

/// corresponding material and the lights that affect it. Some render features like Screen Space

/// Ambient Occlusion require running depth and normal prepasses, that are 'deferred'-like

/// prepasses over all mesh entities to populate depth and normal textures. This means that when

/// using render features that require running prepasses, multiple passes over all visible geometry

/// are required. This can be slow if there is a lot of geometry that cannot be batched into few

/// draws.

/// Deferred rendering runs a prepass to gather not only geometric information like depth and

/// normals, but also all the material properties like base color, emissive color, reflectance,

/// metalness, etc, and writes them into a deferred 'g-buffer' texture. The deferred main pass is

/// then a fullscreen pass that reads data from these textures and executes shading. This allows

/// for one pass over geometry, but is at the cost of not being able to use MSAA, and has heavier

/// bandwidth usage which can be unsuitable for low end mobile or other bandwidth-constrained devices.

/// If a material indicates `OpaqueRendererMethod::Auto`, `DefaultOpaqueRendererMethod` will be used.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::OpaqueRendererMethod",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::OpaqueRendererMethod;

"#]
)]

pub struct LuaOpaqueRendererMethod {}

/// The [parallax mapping] method to use to compute depth based on the

/// material's [`depth_map`].

/// Parallax Mapping uses a depth map texture to give the illusion of depth

/// variation on a mesh surface that is geometrically flat.

/// See the `parallax_mapping.wgsl` shader code for implementation details

/// and explanation of the methods used.

/// [`depth_map`]: crate::StandardMaterial::depth_map

/// [parallax mapping]: https://en.wikipedia.org/wiki/Parallax_mapping

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::ParallaxMappingMethod",
functions[r#"

    #[lua(kind = "Method")]
    fn max_steps(&self) -> u32;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::ParallaxMappingMethod;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &parallax::ParallaxMappingMethod) -> bool;

"#]
)]

pub struct LuaParallaxMappingMethod {}

/// A material with "standard" properties used in PBR lighting

/// Standard property values with pictures here

/// <https://google.github.io/filament/Material%20Properties.pdf>.

/// May be created directly from a [`Color`] or an [`Image`].

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::prelude::StandardMaterial",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::prelude::StandardMaterial;

"#]
)]

pub struct LuaStandardMaterial {}

/// Component to apply screen space ambient occlusion to a 3d camera.

/// Screen space ambient occlusion (SSAO) approximates small-scale,

/// local occlusion of _indirect_ diffuse light between objects, based on what's visible on-screen.

/// SSAO does not apply to direct lighting, such as point or directional lights.

/// This darkens creases, e.g. on staircases, and gives nice contact shadows

/// where objects meet, giving entities a more "grounded" feel.

/// # Usage Notes

/// Requires that you add [`ScreenSpaceAmbientOcclusionPlugin`] to your app,

/// and add the [`DepthPrepass`] and [`NormalPrepass`] components to your camera.

/// It strongly recommended that you use SSAO in conjunction with

/// TAA ([`bevy_core_pipeline::experimental::taa::TemporalAntiAliasSettings`]).

/// Doing so greatly reduces SSAO noise.

/// SSAO is not supported on `WebGL2`, and is not currently supported on `WebGPU` or `DirectX12`.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ScreenSpaceAmbientOcclusionSettings",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ScreenSpaceAmbientOcclusionSettings;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ssao::ScreenSpaceAmbientOcclusionSettings) -> bool;

"#]
)]

pub struct LuaScreenSpaceAmbientOcclusionSettings {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel",
functions[r#"

    #[lua(kind = "Method")]
    fn sample_counts(&self) -> (u32, u32);

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ssao::ScreenSpaceAmbientOcclusionQualityLevel) -> bool;

"#]
)]

pub struct LuaScreenSpaceAmbientOcclusionQualityLevel {}

crate::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances.add_instance(
            "LuaFogFalloff",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaFogFalloff>::new,
        )?;

        instances.add_instance(
            "LuaLightProbe",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaLightProbe>::new,
        )?;

        instances.add_instance("LuaDefaultOpaqueRendererMethod", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaDefaultOpaqueRendererMethod>::new)?;

        Ok(())
    }
}

pub struct BevyPbrAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyPbrAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new(
            "BevyPbrAPI",
            |tw| {
                tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaWireframe>()
                
            
                .process_type::<LuaWireframeColor>()
                
            
                .process_type::<LuaNoWireframe>()
                
            
                .process_type::<LuaWireframeConfig>()
                
            
                .process_type::<LuaAlphaMode>()
                
            
                .process_type::<LuaCubemapVisibleEntities>()
                
            
                .process_type::<LuaCascadesVisibleEntities>()
                
            
                .process_type::<LuaFogSettings>()
                
            
                .process_type::<LuaFogFalloff>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaFogFalloff>>()
                
            
                .process_type::<LuaPointLight>()
                
            
                .process_type::<LuaPointLightShadowMap>()
                
            
                .process_type::<LuaSpotLight>()
                
            
                .process_type::<LuaDirectionalLight>()
                
            
                .process_type::<LuaDirectionalLightShadowMap>()
                
            
                .process_type::<LuaCascadeShadowConfig>()
                
            
                .process_type::<LuaCascades>()
                
            
                .process_type::<LuaCascade>()
                
            
                .process_type::<LuaAmbientLight>()
                
            
                .process_type::<LuaNotShadowCaster>()
                
            
                .process_type::<LuaNotShadowReceiver>()
                
            
                .process_type::<LuaTransmittedShadowReceiver>()
                
            
                .process_type::<LuaShadowFilteringMethod>()
                
            
                .process_type::<LuaClusterFarZMode>()
                
            
                .process_type::<LuaClusterZConfig>()
                
            
                .process_type::<LuaClusterConfig>()
                
            
                .process_type::<LuaEnvironmentMapLight>()
                
            
                .process_type::<LuaIrradianceVolume>()
                
            
                .process_type::<LuaLightProbe>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaLightProbe>>()
                
            
                .process_type::<LuaLightmap>()
                
            
                .process_type::<LuaDefaultOpaqueRendererMethod>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaDefaultOpaqueRendererMethod>>()
                
            
                .process_type::<LuaOpaqueRendererMethod>()
                
            
                .process_type::<LuaParallaxMappingMethod>()
                
            
                .process_type::<LuaStandardMaterial>()
                
            
                .process_type::<LuaScreenSpaceAmbientOcclusionSettings>()
                
            
                .process_type::<LuaScreenSpaceAmbientOcclusionQualityLevel>()
            },
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::pbr::wireframe::Wireframe>();

        app.register_foreign_lua_type::<bevy::pbr::wireframe::WireframeColor>();

        app.register_foreign_lua_type::<bevy::pbr::wireframe::NoWireframe>();

        app.register_foreign_lua_type::<bevy::pbr::wireframe::WireframeConfig>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::AlphaMode>();

        app.register_foreign_lua_type::<bevy::pbr::CubemapVisibleEntities>();

        app.register_foreign_lua_type::<bevy::pbr::CascadesVisibleEntities>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::FogSettings>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::FogFalloff>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::PointLight>();

        app.register_foreign_lua_type::<bevy::pbr::PointLightShadowMap>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::SpotLight>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::DirectionalLight>();

        app.register_foreign_lua_type::<bevy::pbr::DirectionalLightShadowMap>();

        app.register_foreign_lua_type::<bevy::pbr::CascadeShadowConfig>();

        app.register_foreign_lua_type::<bevy::pbr::Cascades>();

        app.register_foreign_lua_type::<bevy::pbr::Cascade>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::AmbientLight>();

        app.register_foreign_lua_type::<bevy::pbr::NotShadowCaster>();

        app.register_foreign_lua_type::<bevy::pbr::NotShadowReceiver>();

        app.register_foreign_lua_type::<bevy::pbr::TransmittedShadowReceiver>();

        app.register_foreign_lua_type::<bevy::pbr::ShadowFilteringMethod>();

        app.register_foreign_lua_type::<bevy::pbr::ClusterFarZMode>();

        app.register_foreign_lua_type::<bevy::pbr::ClusterZConfig>();

        app.register_foreign_lua_type::<bevy::pbr::ClusterConfig>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::EnvironmentMapLight>();

        app.register_foreign_lua_type::<bevy::pbr::irradiance_volume::IrradianceVolume>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::LightProbe>();

        app.register_foreign_lua_type::<bevy::pbr::Lightmap>();

        app.register_foreign_lua_type::<bevy::pbr::DefaultOpaqueRendererMethod>();

        app.register_foreign_lua_type::<bevy::pbr::OpaqueRendererMethod>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::ParallaxMappingMethod>();

        app.register_foreign_lua_type::<bevy::pbr::prelude::StandardMaterial>();

        app.register_foreign_lua_type::<bevy::pbr::ScreenSpaceAmbientOcclusionSettings>();

        app.register_foreign_lua_type::<bevy::pbr::ScreenSpaceAmbientOcclusionQualityLevel>();
    }
}

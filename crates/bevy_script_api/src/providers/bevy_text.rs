#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file


use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_render::*;

use super::bevy_time::*;

use super::bevy_transform::*;

use super::bevy_core_pipeline::*;

use super::bevy_sprite::*;



extern crate self as bevy_script_api;





    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::GlyphAtlasInfo",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::GlyphAtlasInfo;

"#]
)]




pub struct LuaGlyphAtlasInfo{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::PositionedGlyph",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::PositionedGlyph;

"#]
)]




pub struct LuaPositionedGlyph{
    
    
    
}

    
/// Render information for a corresponding [`Text`] component.

///  Contains scaled glyphs and their size. Generated via [`TextPipeline::queue_text`].


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::TextLayoutInfo",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::TextLayoutInfo;

"#]
)]




pub struct LuaTextLayoutInfo{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::prelude::Text",
functions[r#"
/// Returns this [`Text`] with a new [`JustifyText`].

    #[lua(kind = "Method", output(proxy))]
    fn with_justify(
        self,
        #[proxy]
        justify: bevy::text::prelude::JustifyText,
    ) -> bevy::text::prelude::Text;

"#,
			r#"
/// Returns this [`Text`] with soft wrapping disabled.
/// Hard wrapping, where text contains an explicit linebreak such as the escape sequence `\n`, will still occur.

    #[lua(kind = "Method", output(proxy))]
    fn with_no_wrap(self) -> bevy::text::prelude::Text;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::prelude::Text;

"#]
)]




pub struct LuaText{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::prelude::TextSection",
functions[r#"
/// Create an empty [`TextSection`] from a style. Useful when the value will be set dynamically.

    #[lua(kind = "Function", output(proxy))]
    fn from_style(
        #[proxy]
        style: bevy::text::prelude::TextStyle,
    ) -> bevy::text::prelude::TextSection;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::prelude::TextSection;

"#]
)]




pub struct LuaTextSection{
    
    
    
}

    
/// Describes the horizontal alignment of multiple lines of text relative to each other.

/// This only affects the internal positioning of the lines of text within a text entity and

/// does not affect the text entity's position.

/// _Has no affect on a single line text entity._


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::prelude::JustifyText",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::prelude::JustifyText;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &text::JustifyText) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]




pub struct LuaJustifyText{
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::prelude::TextStyle",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::prelude::TextStyle;

"#]
)]




pub struct LuaTextStyle{
    
    
    
}

    
/// Determines how lines will be broken when preventing text from running out of bounds.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::BreakLineOn",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::BreakLineOn;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &text::BreakLineOn) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]




pub struct LuaBreakLineOn{
    
}

    
/// The maximum width and height of text. The text will wrap according to the specified size.

/// Characters out of the bounds after wrapping will be truncated. Text is aligned according to the

/// specified [`JustifyText`](crate::text::JustifyText).

/// Note: only characters that are completely out of the bounds will be truncated, so this is not a

/// reliable limit if it is necessary to contain the text strictly in the bounds. Currently this

/// component is mainly useful for text wrapping only.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::text::Text2dBounds",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::text::Text2dBounds;

"#]
)]




pub struct LuaText2dBounds{
    
    
    
}




crate::impl_tealr_generic!(pub(crate) struct T);


#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaTextSection", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaTextSection>::new)?;
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyTextAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyTextAPIProvider {
        type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new("BevyTextAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaGlyphAtlasInfo>()
                
            
                .process_type::<LuaPositionedGlyph>()
                
            
                .process_type::<LuaTextLayoutInfo>()
                
            
                .process_type::<LuaText>()
                
            
                .process_type::<LuaTextSection>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaTextSection>>()
                
            
                .process_type::<LuaJustifyText>()
                
            
                .process_type::<LuaTextStyle>()
                
            
                .process_type::<LuaBreakLineOn>()
                
            
                .process_type::<LuaText2dBounds>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        
        app.register_foreign_lua_type::<bevy::text::GlyphAtlasInfo>();
        
        app.register_foreign_lua_type::<bevy::text::PositionedGlyph>();
        
        app.register_foreign_lua_type::<bevy::text::TextLayoutInfo>();
        
        app.register_foreign_lua_type::<bevy::text::prelude::Text>();
        
        app.register_foreign_lua_type::<bevy::text::prelude::TextSection>();
        
        app.register_foreign_lua_type::<bevy::text::prelude::JustifyText>();
        
        app.register_foreign_lua_type::<bevy::text::prelude::TextStyle>();
        
        app.register_foreign_lua_type::<bevy::text::BreakLineOn>();
        
        app.register_foreign_lua_type::<bevy::text::Text2dBounds>();
        
    }
}
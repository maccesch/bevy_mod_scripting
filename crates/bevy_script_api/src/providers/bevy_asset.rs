#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file


use super::bevy_ecs::*;

use super::bevy_reflect::*;



extern crate self as bevy_script_api;





    
/// A generational runtime-only identifier for a specific [`Asset`] stored in [`Assets`]. This is optimized for efficient runtime

/// usage and is not suitable for identifying assets across app runs.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::asset::AssetIndex",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::asset::AssetIndex;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &assets::AssetIndex) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]




pub struct LuaAssetIndex{
    
    
        
    
        
    
    
}

    
/// Represents a path to an asset in a "virtual filesystem".

/// Asset paths consist of three main parts:

/// * [`AssetPath::source`]: The name of the [`AssetSource`](crate::io::AssetSource) to load the asset from.

///     This is optional. If one is not set the default source will be used (which is the `assets` folder by default).

/// * [`AssetPath::path`]: The "virtual filesystem path" pointing to an asset source file.

/// * [`AssetPath::label`]: An optional "named sub asset". When assets are loaded, they are

/// allowed to load "sub assets" of any type, which are identified by a named "label".

/// Asset paths are generally constructed (and visualized) as strings:

/// ```no_run

/// # use bevy_asset::{Asset, AssetServer, Handle};

/// # use bevy_reflect::TypePath;

/// #

/// # #[derive(Asset, TypePath, Default)]

/// # struct Mesh;

/// #

/// # #[derive(Asset, TypePath, Default)]

/// # struct Scene;

/// #

/// # let asset_server: AssetServer = panic!();

/// // This loads the `my_scene.scn` base asset from the default asset source.

/// let scene: Handle<Scene> = asset_server.load("my_scene.scn");

/// // This loads the `PlayerMesh` labeled asset from the `my_scene.scn` base asset in the default asset source.

/// let mesh: Handle<Mesh> = asset_server.load("my_scene.scn#PlayerMesh");

/// // This loads the `my_scene.scn` base asset from a custom 'remote' asset source.

/// let scene: Handle<Scene> = asset_server.load("remote://my_scene.scn");

/// ```

/// [`AssetPath`] implements [`From`] for `&'static str`, `&'static Path`, and `&'a String`,

/// which allows us to optimize the static cases.

/// This means that the common case of `asset_server.load("my_scene.scn")` when it creates and

/// clones internal owned [`AssetPaths`](AssetPath).

/// This also means that you should use [`AssetPath::parse`] in cases where `&str` is the explicit type.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::asset::AssetPath",
functions[r#"
/// Gets the "sub-asset label".

    #[lua(kind = "Method")]
    fn label(&self) -> std::option::Option<&str>;

"#,
			r#"
/// Gets the path to the asset in the "virtual filesystem" without a label (if a label is currently set).

    #[lua(kind = "Method", output(proxy))]
    fn without_label(&self) -> bevy::asset::AssetPath<'_>;

"#,
			r#"
/// Removes a "sub-asset label" from this [`AssetPath`], if one was set.

    #[lua(kind = "Method")]
    fn remove_label(&mut self) -> ();

"#,
			r#"
/// Converts this into an "owned" value. If internally a value is borrowed, it will be cloned into an "owned [`Arc`]".
/// If internally a value is a static reference, the static reference will be used unchanged.
/// If internally a value is an "owned [`Arc`]", it will remain unchanged.
/// [`Arc`]: std::sync::Arc

    #[lua(kind = "Method", output(proxy))]
    fn into_owned(self) -> bevy::asset::AssetPath<'_>;

"#,
			r#"
/// Clones this into an "owned" value. If internally a value is borrowed, it will be cloned into an "owned [`Arc`]".
/// If internally a value is a static reference, the static reference will be used unchanged.
/// If internally a value is an "owned [`Arc`]", the [`Arc`] will be cloned.
/// [`Arc`]: std::sync::Arc

    #[lua(kind = "Method", output(proxy))]
    fn clone_owned(&self) -> bevy::asset::AssetPath<'_>;

"#,
			r#"
/// Returns the full extension (including multiple '.' values).
/// Ex: Returns `"config.ron"` for `"my_asset.config.ron"`

    #[lua(kind = "Method")]
    fn get_full_extension(&self) -> std::option::Option<std::string::String>;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::asset::AssetPath<'_>;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &path::AssetPath<'_>) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]




pub struct LuaAssetPath{
    
    
        
    
        
    
        
    
    
}




crate::impl_tealr_generic!(pub(crate) struct T);


#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyAssetAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyAssetAPIProvider {
        type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new("BevyAssetAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaAssetIndex>()
                
            
                .process_type::<LuaAssetPath>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        
        app.register_foreign_lua_type::<bevy::asset::AssetIndex>();
        
        app.register_foreign_lua_type::<bevy::asset::AssetPath>();
        
    }
}
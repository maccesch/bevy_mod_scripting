#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file

use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_render::*;

use super::bevy_time::*;

use super::bevy_transform::*;

extern crate self as bevy_script_api;

/// Applies a bloom effect to an HDR-enabled 2d or 3d camera.

/// Bloom emulates an effect found in real cameras and the human eye,

/// causing halos to appear around very bright parts of the scene.

/// See also <https://en.wikipedia.org/wiki/Bloom_(shader_effect)>.

/// # Usage Notes

/// **Bloom is currently not compatible with WebGL2.**

/// Often used in conjunction with `bevy_pbr::StandardMaterial::emissive` for 3d meshes.

/// Bloom is best used alongside a tonemapping function that desaturates bright colors,

/// such as [`crate::tonemapping::Tonemapping::TonyMcMapface`].

/// Bevy's implementation uses a parametric curve to blend between a set of

/// blurred (lower frequency) images generated from the camera's view.

/// See <https://starlederer.github.io/bloom/> for a visualization of the parametric curve

/// used in Bevy as well as a visualization of the curve's respective scattering profile.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::bloom::BloomSettings",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::bloom::BloomSettings;

"#]
)]

pub struct LuaBloomSettings {}

/// Applies a threshold filter to the input image to extract the brightest

/// regions before blurring them and compositing back onto the original image.

/// These settings are useful when emulating the 1990s-2000s game look.

/// # Considerations

/// * Changing these settings creates a physically inaccurate image

/// * Changing these settings makes it easy to make the final result look worse

/// * Non-default prefilter settings should be used in conjunction with [`BloomCompositeMode::Additive`]

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::bloom::BloomPrefilterSettings",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::bloom::BloomPrefilterSettings;

"#]
)]

pub struct LuaBloomPrefilterSettings {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::bloom::BloomCompositeMode",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::bloom::BloomCompositeMode;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &bloom::settings::BloomCompositeMode) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaBloomCompositeMode {}

/// Applies a contrast adaptive sharpening (CAS) filter to the camera.

/// CAS is usually used in combination with shader based anti-aliasing methods

/// such as FXAA or TAA to regain some of the lost detail from the blurring that they introduce.

/// CAS is designed to adjust the amount of sharpening applied to different areas of an image

/// based on the local contrast. This can help avoid over-sharpening areas with high contrast

/// and under-sharpening areas with low contrast.

/// To use this, add the [`ContrastAdaptiveSharpeningSettings`] component to a 2D or 3D camera.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(
        &self,
    ) -> bevy::core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings;

"#]
)]

pub struct LuaContrastAdaptiveSharpeningSettings {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::contrast_adaptive_sharpening::DenoiseCAS",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::contrast_adaptive_sharpening::DenoiseCAS;

"#]
)]

pub struct LuaDenoiseCAS();

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::core_2d::Camera2d",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::core_2d::Camera2d;

"#]
)]

pub struct LuaCamera2d {}

/// Configuration for the "main 3d render graph".

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::core_3d::Camera3d",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::core_3d::Camera3d;

"#]
)]

pub struct LuaCamera3d {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::core_3d::Camera3dDepthTextureUsage",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::core_3d::Camera3dDepthTextureUsage;

"#]
)]

pub struct LuaCamera3dDepthTextureUsage();

/// The depth clear operation to perform for the main 3d pass.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::core_3d::Camera3dDepthLoadOp",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::core_3d::Camera3dDepthLoadOp;

"#]
)]

pub struct LuaCamera3dDepthLoadOp {}

/// The quality of the screen space transmission blur effect, applied to whatever's “behind” transmissive

/// objects when their `roughness` is greater than `0.0`.

/// Higher qualities are more GPU-intensive.

/// **Note:** You can get better-looking results at any quality level by enabling TAA. See: [`TemporalAntiAliasPlugin`](crate::experimental::taa::TemporalAntiAliasPlugin).

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::core_3d::ScreenSpaceTransmissionQuality",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::core_3d::ScreenSpaceTransmissionQuality;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(
        &self,
        #[proxy]
        other: &core_3d::camera_3d::ScreenSpaceTransmissionQuality,
    ) -> bool;

"#]
)]

pub struct LuaScreenSpaceTransmissionQuality {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::fxaa::Sensitivity",
functions[r#"

    #[lua(kind = "Method")]
    fn get_str(&self) -> &str;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::fxaa::Sensitivity;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &fxaa::Sensitivity) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaSensitivity {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::fxaa::Fxaa",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::fxaa::Fxaa;

"#]
)]

pub struct LuaFxaa {}

/// If added to a [`crate::prelude::Camera3d`] then depth values will be copied to a separate texture available to the main pass.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::prepass::DepthPrepass",
functions[]
)]

pub struct LuaDepthPrepass {}

/// If added to a [`crate::prelude::Camera3d`] then vertex world normals will be copied to a separate texture available to the main pass.

/// Normals will have normal map textures already applied.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::prepass::NormalPrepass",
functions[]
)]

pub struct LuaNormalPrepass {}

/// If added to a [`crate::prelude::Camera3d`] then screen space motion vectors will be copied to a separate texture available to the main pass.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::prepass::MotionVectorPrepass",
functions[]
)]

pub struct LuaMotionVectorPrepass {}

/// If added to a [`crate::prelude::Camera3d`] then deferred materials will be rendered to the deferred gbuffer texture and will be available to subsequent passes.

/// Note the default deferred lighting plugin also requires `DepthPrepass` to work correctly.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::prepass::DeferredPrepass",
functions[]
)]

pub struct LuaDeferredPrepass {}

/// Component to apply temporal anti-aliasing to a 3D perspective camera.

/// Temporal anti-aliasing (TAA) is a form of image smoothing/filtering, like

/// multisample anti-aliasing (MSAA), or fast approximate anti-aliasing (FXAA).

/// TAA works by blending (averaging) each frame with the past few frames.

/// # Tradeoffs

/// Pros:

/// * Filters more types of aliasing than MSAA, such as textures and singular bright pixels (specular aliasing)

/// * Cost scales with screen/view resolution, unlike MSAA which scales with number of triangles

/// * Greatly increases the quality of stochastic rendering techniques such as SSAO, certain shadow map sampling methods, etc

/// Cons:

/// * Chance of "ghosting" - ghostly trails left behind moving objects

/// * Thin geometry, lighting detail, or texture lines may flicker noisily or disappear

/// Because TAA blends past frames with the current frame, when the frames differ too much

/// (such as with fast moving objects or camera cuts), ghosting artifacts may occur.

/// Artifacts tend to be reduced at higher framerates and rendering resolution.

/// # Usage Notes

/// Requires that you add [`TemporalAntiAliasPlugin`] to your app,

/// and add the [`DepthPrepass`], [`MotionVectorPrepass`], and [`TemporalJitter`]

/// components to your camera.

/// [Currently](https://github.com/bevyengine/bevy/issues/8423) cannot be used with [`bevy_render::camera::OrthographicProjection`].

/// Currently does not support skinned meshes and morph targets.

/// There will probably be ghosting artifacts if used with them.

/// Does not work well with alpha-blended meshes as it requires depth writing to determine motion.

/// It is very important that correct motion vectors are written for everything on screen.

/// Failure to do so will lead to ghosting artifacts. For instance, if particle effects

/// are added using a third party library, the library must either:

/// 1. Write particle motion vectors to the motion vectors prepass texture

/// 2. Render particles after TAA

/// If no [`MipBias`] component is attached to the camera, TAA will add a MipBias(-1.0) component.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::experimental::taa::TemporalAntiAliasSettings",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::experimental::taa::TemporalAntiAliasSettings;

"#]
)]

pub struct LuaTemporalAntiAliasSettings {}

/// Optionally enables a tonemapping shader that attempts to map linear input stimulus into a perceptually uniform image for a given [`Camera`] entity.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::tonemapping::Tonemapping",
functions[r#"

    #[lua(kind = "Method")]
    fn is_enabled(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::tonemapping::Tonemapping;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &tonemapping::Tonemapping) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaTonemapping {}

/// Enables a debanding shader that applies dithering to mitigate color banding in the final image for a given [`Camera`] entity.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::core_pipeline::tonemapping::DebandDither",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::core_pipeline::tonemapping::DebandDither;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &tonemapping::DebandDither) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaDebandDither {}

crate::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        Ok(())
    }
}

pub struct BevyCorePipelineAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyCorePipelineAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new(
            "BevyCorePipelineAPI",
            |tw| {
                tw.document_global_instance::<Globals>()
                    .expect("Something went wrong documenting globals")
                    .process_type::<LuaBloomSettings>()
                    .process_type::<LuaBloomPrefilterSettings>()
                    .process_type::<LuaBloomCompositeMode>()
                    .process_type::<LuaContrastAdaptiveSharpeningSettings>()
                    .process_type::<LuaDenoiseCAS>()
                    .process_type::<LuaCamera2d>()
                    .process_type::<LuaCamera3d>()
                    .process_type::<LuaCamera3dDepthTextureUsage>()
                    .process_type::<LuaCamera3dDepthLoadOp>()
                    .process_type::<LuaScreenSpaceTransmissionQuality>()
                    .process_type::<LuaSensitivity>()
                    .process_type::<LuaFxaa>()
                    .process_type::<LuaDepthPrepass>()
                    .process_type::<LuaNormalPrepass>()
                    .process_type::<LuaMotionVectorPrepass>()
                    .process_type::<LuaDeferredPrepass>()
                    .process_type::<LuaTemporalAntiAliasSettings>()
                    .process_type::<LuaTonemapping>()
                    .process_type::<LuaDebandDither>()
            },
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::core_pipeline::bloom::BloomSettings>();

        app.register_foreign_lua_type::<bevy::core_pipeline::bloom::BloomPrefilterSettings>();

        app.register_foreign_lua_type::<bevy::core_pipeline::bloom::BloomCompositeMode>();

        app.register_foreign_lua_type::<bevy::core_pipeline::contrast_adaptive_sharpening::ContrastAdaptiveSharpeningSettings>();

        app.register_foreign_lua_type::<bevy::core_pipeline::contrast_adaptive_sharpening::DenoiseCAS>();

        app.register_foreign_lua_type::<bevy::core_pipeline::core_2d::Camera2d>();

        app.register_foreign_lua_type::<bevy::core_pipeline::core_3d::Camera3d>();

        app.register_foreign_lua_type::<bevy::core_pipeline::core_3d::Camera3dDepthTextureUsage>();

        app.register_foreign_lua_type::<bevy::core_pipeline::core_3d::Camera3dDepthLoadOp>();

        app.register_foreign_lua_type::<bevy::core_pipeline::core_3d::ScreenSpaceTransmissionQuality>();

        app.register_foreign_lua_type::<bevy::core_pipeline::fxaa::Sensitivity>();

        app.register_foreign_lua_type::<bevy::core_pipeline::fxaa::Fxaa>();

        app.register_foreign_lua_type::<bevy::core_pipeline::prepass::DepthPrepass>();

        app.register_foreign_lua_type::<bevy::core_pipeline::prepass::NormalPrepass>();

        app.register_foreign_lua_type::<bevy::core_pipeline::prepass::MotionVectorPrepass>();

        app.register_foreign_lua_type::<bevy::core_pipeline::prepass::DeferredPrepass>();

        app.register_foreign_lua_type::<bevy::core_pipeline::experimental::taa::TemporalAntiAliasSettings>();

        app.register_foreign_lua_type::<bevy::core_pipeline::tonemapping::Tonemapping>();

        app.register_foreign_lua_type::<bevy::core_pipeline::tonemapping::DebandDither>();
    }
}

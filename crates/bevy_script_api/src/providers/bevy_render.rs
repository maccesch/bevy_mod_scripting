#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file


use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_time::*;

use super::bevy_transform::*;



extern crate self as bevy_script_api;





    
/// Render viewport configuration for the [`Camera`] component.

/// The viewport defines the area on the render target to which the camera renders its image.

/// You can overlay multiple cameras in a single window using viewports to create effects like

/// split screen, minimaps, and character viewers.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::Viewport",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::Viewport;

"#]
)]




pub struct LuaViewport{
    
    
    
}

    
/// How much energy a `Camera3d` absorbs from incoming light.

/// <https://en.wikipedia.org/wiki/Exposure_(photography)>


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::Exposure",
functions[r#"
/// Converts EV100 values to exposure values.
/// <https://google.github.io/filament/Filament.md.html#imagingpipeline/physicallybasedcamera/exposure>

    #[lua(kind = "Method")]
    fn exposure(&self) -> f32;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::Exposure;

"#]
)]




pub struct LuaExposure{
    
    
    
}

    
/// The defining [`Component`] for camera entities,

/// storing information about how and what to render through this camera.

/// The [`Camera`] component is added to an entity to define the properties of the viewpoint from

/// which rendering occurs. It defines the position of the view to render, the projection method

/// to transform the 3D objects into a 2D image, as well as the render target into which that image

/// is produced.

/// Adding a camera is typically done by adding a bundle, either the `Camera2dBundle` or the

/// `Camera3dBundle`.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::Camera",
functions[r#"

    #[lua(kind = "Method")]
    fn target_scaling_factor(&self) -> std::option::Option<f32>;

"#,
			r#"
/// The projection matrix computed using this camera's [`CameraProjection`].

    #[lua(kind = "Method", output(proxy))]
    fn projection_matrix(&self) -> bevy::math::Mat4;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::Camera;

"#]
)]




pub struct LuaCamera{
    
    
    
}

    
/// Configures the [`RenderGraph`](crate::render_graph::RenderGraph) name assigned to be run for a given [`Camera`] entity.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::CameraRenderGraph",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::CameraRenderGraph;

"#]
)]



pub struct LuaCameraRenderGraph(
    
    
        
    
    
);

    
/// The "target" that a [`Camera`] will render to. For example, this could be a [`Window`]

/// swapchain or an [`Image`].


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::RenderTarget",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::RenderTarget;

"#]
)]




pub struct LuaRenderTarget{
    
}

    
/// Normalized version of the render target.

/// Once we have this we shouldn't need to resolve it down anymore.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::NormalizedRenderTarget",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::NormalizedRenderTarget;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &camera::camera::NormalizedRenderTarget) -> bool;

"#]
)]




pub struct LuaNormalizedRenderTarget{
    
}

    
/// This component lets you control the [`TextureUsages`] field of the main texture generated for the camera


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::CameraMainTextureUsages",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::CameraMainTextureUsages;

"#]
)]



pub struct LuaCameraMainTextureUsages(
    
    
    
);

    
/// For a camera, specifies the color used to clear the viewport before rendering.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::ClearColorConfig",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::ClearColorConfig;

"#]
)]




pub struct LuaClearColorConfig{
    
}

    
/// A [`Resource`] that stores the color that is used to clear the screen between frames.

/// This color appears as the "background" color for simple apps,

/// when there are portions of the screen with nothing rendered.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::ClearColor",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::ClearColor;

"#]
)]



pub struct LuaClearColor(
    
    
    
);

    
/// A unique id that corresponds to a specific [`ManualTextureView`] in the [`ManualTextureViews`] collection.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::ManualTextureViewHandle",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::ManualTextureViewHandle;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(
        &self,
        #[proxy]
        other: &camera::manual_texture_view::ManualTextureViewHandle,
    ) -> bool;

"#]
)]



pub struct LuaManualTextureViewHandle(
    
    
    
);

    
/// A configurable [`CameraProjection`] that can select its projection type at runtime.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::Projection",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::Projection;

"#]
)]




pub struct LuaProjection{
    
}

    
/// A 3D camera projection in which distant objects appear smaller than close objects.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::PerspectiveProjection",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::PerspectiveProjection;

"#]
)]




pub struct LuaPerspectiveProjection{
    
    
    
}

    
/// Scaling mode for [`OrthographicProjection`].

/// # Examples

/// Configure the orthographic projection to two world units per window height:

/// ```

/// # use bevy_render::camera::{OrthographicProjection, Projection, ScalingMode};

/// let projection = Projection::Orthographic(OrthographicProjection {

///    scaling_mode: ScalingMode::FixedVertical(2.0),

///    ..OrthographicProjection::default()

/// });

/// ```


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::ScalingMode",
functions[r#"
/// Scale the `ScalingMode`. For example, multiplying by 2 makes the viewport twice as large.

    #[lua(
        as_trait = "std::ops::Mul",
        kind = "Function",
        output(proxy),
        composite = "mul",
        metamethod = "Mul",
    )]
    fn mul(self, rhs: f32) -> bevy::render::camera::ScalingMode;

"#,
			r#"
/// Scale the `ScalingMode`. For example, dividing by 2 makes the viewport half as large.

    #[lua(
        as_trait = "std::ops::Div",
        kind = "Function",
        output(proxy),
        composite = "div",
        metamethod = "Div",
    )]
    fn div(self, rhs: f32) -> bevy::render::camera::ScalingMode;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::ScalingMode;

"#]
)]




pub struct LuaScalingMode{
    
}

    
/// Project a 3D space onto a 2D surface using parallel lines, i.e., unlike [`PerspectiveProjection`],

/// the size of objects remains the same regardless of their distance to the camera.

/// The volume contained in the projection is called the *view frustum*. Since the viewport is rectangular

/// and projection lines are parallel, the view frustum takes the shape of a cuboid.

/// Note that the scale of the projection and the apparent size of objects are inversely proportional.

/// As the size of the projection increases, the size of objects decreases.

/// # Examples

/// Configure the orthographic projection to one world unit per 100 window pixels:

/// ```

/// # use bevy_render::camera::{OrthographicProjection, Projection, ScalingMode};

/// let projection = Projection::Orthographic(OrthographicProjection {

///     scaling_mode: ScalingMode::WindowSize(100.0),

///     ..OrthographicProjection::default()

/// });

/// ```


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::camera::OrthographicProjection",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::camera::OrthographicProjection;

"#]
)]




pub struct LuaOrthographicProjection{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::color::Color",
functions[r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].

    #[lua(kind = "Function", output(proxy))]
    fn rgb(r: f32, g: f32, b: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// * `a` - Alpha channel. [0.0, 1.0]
/// See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].

    #[lua(kind = "Function", output(proxy))]
    fn rgba(r: f32, g: f32, b: f32, a: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` from linear RGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// See also [`Color::rgb`], [`Color::rgba_linear`].

    #[lua(kind = "Function", output(proxy))]
    fn rgb_linear(r: f32, g: f32, b: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` from linear RGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0.0, 1.0]
/// * `g` - Green channel. [0.0, 1.0]
/// * `b` - Blue channel. [0.0, 1.0]
/// * `a` - Alpha channel. [0.0, 1.0]
/// See also [`Color::rgba`], [`Color::rgb_linear`].

    #[lua(kind = "Function", output(proxy))]
    fn rgba_linear(r: f32, g: f32, b: f32, a: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` with HSL representation in sRGB colorspace.
/// # Arguments
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `saturation` - Saturation channel. [0.0, 1.0]
/// * `lightness` - Lightness channel. [0.0, 1.0]
/// See also [`Color::hsla`].

    #[lua(kind = "Function", output(proxy))]
    fn hsl(hue: f32, saturation: f32, lightness: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` with HSL representation in sRGB colorspace.
/// # Arguments
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `saturation` - Saturation channel. [0.0, 1.0]
/// * `lightness` - Lightness channel. [0.0, 1.0]
/// * `alpha` - Alpha channel. [0.0, 1.0]
/// See also [`Color::hsl`].

    #[lua(kind = "Function", output(proxy))]
    fn hsla(
        hue: f32,
        saturation: f32,
        lightness: f32,
        alpha: f32,
    ) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` with LCH representation in sRGB colorspace.
/// # Arguments
/// * `lightness` - Lightness channel. [0.0, 1.5]
/// * `chroma` - Chroma channel. [0.0, 1.5]
/// * `hue` - Hue channel. [0.0, 360.0]
/// See also [`Color::lcha`].

    #[lua(kind = "Function", output(proxy))]
    fn lch(lightness: f32, chroma: f32, hue: f32) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` with LCH representation in sRGB colorspace.
/// # Arguments
/// * `lightness` - Lightness channel. [0.0, 1.5]
/// * `chroma` - Chroma channel. [0.0, 1.5]
/// * `hue` - Hue channel. [0.0, 360.0]
/// * `alpha` - Alpha channel. [0.0, 1.0]
/// See also [`Color::lch`].

    #[lua(kind = "Function", output(proxy))]
    fn lcha(
        lightness: f32,
        chroma: f32,
        hue: f32,
        alpha: f32,
    ) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0, 255]
/// * `g` - Green channel. [0, 255]
/// * `b` - Blue channel. [0, 255]
/// See also [`Color::rgb`], [`Color::rgba_u8`], [`Color::hex`].

    #[lua(kind = "Function", output(proxy))]
    fn rgb_u8(r: u8, g: u8, b: u8) -> bevy::render::color::Color;

"#,
			r#"
/// New `Color` from sRGB colorspace.
/// # Arguments
/// * `r` - Red channel. [0, 255]
/// * `g` - Green channel. [0, 255]
/// * `b` - Blue channel. [0, 255]
/// * `a` - Alpha channel. [0, 255]
/// See also [`Color::rgba`], [`Color::rgb_u8`], [`Color::hex`].

    #[lua(kind = "Function", output(proxy))]
    fn rgba_u8(r: u8, g: u8, b: u8, a: u8) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return red in sRGB colorspace

    #[lua(kind = "Method")]
    fn r(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return green in sRGB colorspace

    #[lua(kind = "Method")]
    fn g(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return blue in sRGB colorspace

    #[lua(kind = "Method")]
    fn b(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return this color with red set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_r(self, r: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return this color with green set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_g(self, g: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Rgba`] and return this color with blue set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_b(self, b: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return hue

    #[lua(kind = "Method")]
    fn h(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return saturation

    #[lua(kind = "Method")]
    fn s(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return lightness

    #[lua(kind = "Method")]
    fn l(&self) -> f32;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return this color with hue set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_h(self, h: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return this color with saturation set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_s(self, s: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a Color to variant [`Color::Hsla`] and return this color with lightness set to a new value

    #[lua(kind = "Method", output(proxy))]
    fn with_l(self, l: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Get alpha.

    #[lua(kind = "Method")]
    fn a(&self) -> f32;

"#,
			r#"
/// Returns this color with a new alpha value.

    #[lua(kind = "Method", output(proxy))]
    fn with_a(self, a: f32) -> bevy::render::color::Color;

"#,
			r#"
/// Determine if the color is fully transparent, i.e. if the alpha is 0.
/// # Examples
/// ```
/// # use bevy_render::color::Color;
/// // Fully transparent colors
/// assert!(Color::NONE.is_fully_transparent());
/// assert!(Color::rgba(1.0, 0.5, 0.5, 0.0).is_fully_transparent());
/// // (Partially) opaque colors
/// assert!(!Color::BLACK.is_fully_transparent());
/// assert!(!Color::rgba(1.0, 0.5, 0.5, 0.2).is_fully_transparent());
/// ```

    #[lua(kind = "Method")]
    fn is_fully_transparent(&self) -> bool;

"#,
			r#"
/// Converts a `Color` to variant `Color::Rgba`

    #[lua(kind = "Method", output(proxy))]
    fn as_rgba(&self) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a `Color` to variant `Color::RgbaLinear`

    #[lua(kind = "Method", output(proxy))]
    fn as_rgba_linear(&self) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a `Color` to variant `Color::Hsla`

    #[lua(kind = "Method", output(proxy))]
    fn as_hsla(&self) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a `Color` to variant `Color::Lcha`

    #[lua(kind = "Method", output(proxy))]
    fn as_lcha(&self) -> bevy::render::color::Color;

"#,
			r#"
/// Converts a `Color` to a `[u8; 4]` from sRGB colorspace

    #[lua(kind = "Method")]
    fn as_rgba_u8(&self) -> [u8; 4];

"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from sRGB colorspace

    #[lua(kind = "Method")]
    fn as_rgba_f32(self) -> [f32; 4];

"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from linear RGB colorspace

    #[lua(kind = "Method")]
    fn as_linear_rgba_f32(self) -> [f32; 4];

"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from HSL colorspace

    #[lua(kind = "Method")]
    fn as_hsla_f32(self) -> [f32; 4];

"#,
			r#"
/// Converts a `Color` to a `[f32; 4]` from LCH colorspace

    #[lua(kind = "Method")]
    fn as_lcha_f32(self) -> [f32; 4];

"#,
			r#"
/// Converts `Color` to a `u32` from sRGB colorspace.
/// Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
/// `A` will be the most significant byte and `R` the least significant.

    #[lua(kind = "Method")]
    fn as_rgba_u32(self) -> u32;

"#,
			r#"
/// Converts Color to a u32 from linear RGB colorspace.
/// Maps the RGBA channels in RGBA order to a little-endian byte array (GPUs are little-endian).
/// `A` will be the most significant byte and `R` the least significant.

    #[lua(kind = "Method")]
    fn as_linear_rgba_u32(self) -> u32;

"#,
			r#"
/// Convert `Color` to RGBA and return as `Vec4`.

    #[lua(kind = "Method", output(proxy))]
    fn rgba_to_vec4(&self) -> bevy::math::Vec4;

"#,
			r#"
/// Convert `Color` to RGBA and return as `Vec3`.

    #[lua(kind = "Method", output(proxy))]
    fn rgb_to_vec3(&self) -> bevy::math::Vec3;

"#,
			r#"
/// Convert `Color` to linear RGBA and return as `Vec4`.

    #[lua(kind = "Method", output(proxy))]
    fn rgba_linear_to_vec4(&self) -> bevy::math::Vec4;

"#,
			r#"
/// Convert `Color` to linear RGBA and return as `Vec3`.

    #[lua(kind = "Method", output(proxy))]
    fn rgb_linear_to_vec3(&self) -> bevy::math::Vec3;

"#,
			r#"
/// Convert `Color` to HSLA and return as `Vec4`.

    #[lua(kind = "Method", output(proxy))]
    fn hsla_to_vec4(&self) -> bevy::math::Vec4;

"#,
			r#"
/// Convert `Color` to HSLA and return as `Vec3`.

    #[lua(kind = "Method", output(proxy))]
    fn hsl_to_vec3(&self) -> bevy::math::Vec3;

"#,
			r#"
/// Convert `Color` to LCHA and return as `Vec4`.

    #[lua(kind = "Method", output(proxy))]
    fn lcha_to_vec4(&self) -> bevy::math::Vec4;

"#,
			r#"
/// Convert `Color` to LCHA and return as `Vec3`.

    #[lua(kind = "Method", output(proxy))]
    fn lch_to_vec3(&self) -> bevy::math::Vec3;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Add",
        kind = "Function",
        output(proxy),
        composite = "add",
        metamethod = "Add",
    )]
    fn add(self, #[proxy] rhs: bevy::render::color::Color) -> bevy::render::color::Color;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::color::Color;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &color::Color) -> bool;

"#]
)]




pub struct LuaColor{
    
}

    
/// Contains global values useful when writing shaders.

/// Currently only contains values related to time.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::globals::GlobalsUniform",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::globals::GlobalsUniform;

"#]
)]




pub struct LuaGlobalsUniform{
    
    
        
    
        
    
        
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::mesh::skinning::SkinnedMesh",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::mesh::skinning::SkinnedMesh;

"#]
)]




pub struct LuaSkinnedMesh{
    
    
    
}

    
/// A 3D object made out of vertices representing triangles, lines, or points,

/// with "attribute" values for each vertex.

/// Meshes can be automatically generated by a bevy `AssetLoader` (generally by loading a `Gltf` file),

/// or by converting a primitive [`shape`](crate::mesh::shape) using [`into`](Into).

/// It is also possible to create one manually.

/// They can be edited after creation.

/// Meshes can be rendered with a `Material`, like `StandardMaterial` in `PbrBundle`

/// or `ColorMaterial` in `ColorMesh2dBundle`.

/// A [`Mesh`] in Bevy is equivalent to a "primitive" in the glTF format, for a

/// glTF Mesh representation, see `GltfMesh`.

/// ## Manual creation

/// The following function will construct a flat mesh, to be rendered with a

/// `StandardMaterial` or `ColorMaterial`:

/// ```

/// # use bevy_render::mesh::{Mesh, Indices};

/// # use bevy_render::render_resource::PrimitiveTopology;

/// # use bevy_render::render_asset::RenderAssetUsages;

/// fn create_simple_parallelogram() -> Mesh {

///     // Create a new mesh using a triangle list topology, where each set of 3 vertices composes a triangle.

///     Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::default())

///         // Add 4 vertices, each with its own position attribute (coordinate in

///         // 3D space), for each of the corners of the parallelogram.

///         .with_inserted_attribute(

///             Mesh::ATTRIBUTE_POSITION,

///             vec![[0.0, 0.0, 0.0], [1.0, 2.0, 0.0], [2.0, 2.0, 0.0], [1.0, 0.0, 0.0]]

///         )

///         // Assign a UV coordinate to each vertex.

///         .with_inserted_attribute(

///             Mesh::ATTRIBUTE_UV_0,

///             vec![[0.0, 1.0], [0.5, 0.0], [1.0, 0.0], [0.5, 1.0]]

///         )

///         // Assign normals (everything points outwards)

///         .with_inserted_attribute(

///             Mesh::ATTRIBUTE_NORMAL,

///             vec![[0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0], [0.0, 0.0, 1.0]]

///         )

///         // After defining all the vertices and their attributes, build each triangle using the

///         // indices of the vertices that make it up in a counter-clockwise order.

///         .with_inserted_indices(Indices::U32(vec![

///             // First triangle

///             0, 3, 1,

///             // Second triangle

///             1, 3, 2

///         ]))

/// }

/// ```

/// You can see how it looks like [here](https://github.com/bevyengine/bevy/blob/main/assets/docs/Mesh.png),

/// used in a `PbrBundle` with a square bevy logo texture, with added axis, points,

/// lines and text for clarity.

/// ## Other examples

/// For further visualization, explanation, and examples, see the built-in Bevy examples,

/// and the [implementation of the built-in shapes](https://github.com/bevyengine/bevy/tree/main/crates/bevy_render/src/mesh/shape).

/// In particular, [generate_custom_mesh](https://github.com/bevyengine/bevy/blob/main/examples/3d/generate_custom_mesh.rs)

/// teaches you to access modify a Mesh's attributes after creating it.

/// ## Common points of confusion

/// - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),

/// other APIs can have other conventions, `OpenGL` starts at bottom-left.

/// - It is possible and sometimes useful for multiple vertices to have the same

/// [position attribute](Mesh::ATTRIBUTE_POSITION) value,

/// it's a common technique in 3D modelling for complex UV mapping or other calculations.

/// ## Use with `StandardMaterial`

/// To render correctly with `StandardMaterial`, a mesh needs to have properly defined:

/// - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh

/// (also true for `ColorMaterial`).

/// - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.

/// [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,

/// because simple meshes are smooth and they don't require complex light calculations.

/// - Vertex winding order: by default, `StandardMaterial.cull_mode` is [`Some(Face::Back)`](crate::render_resource::Face),

/// which means that Bevy would *only* render the "front" of each triangle, which

/// is the side of the triangle from where the vertices appear in a *counter-clockwise* order.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::mesh::Mesh",
functions[r#"
/// Sets the vertex indices of the mesh. They describe how triangles are constructed out of the
/// vertex attributes and are therefore only useful for the [`PrimitiveTopology`] variants
/// that use triangles.

    #[lua(kind = "Method")]
    fn insert_indices(&mut self, #[proxy] indices: bevy::render::mesh::Indices) -> ();

"#,
			r#"
/// Consumes the mesh and returns a mesh with the given vertex indices. They describe how triangles
/// are constructed out of the vertex attributes and are therefore only useful for the
/// [`PrimitiveTopology`] variants that use triangles.
/// (Alternatively, you can use [`Mesh::insert_indices`] to mutate an existing mesh in-place)

    #[lua(kind = "Method", output(proxy))]
    fn with_inserted_indices(
        self,
        #[proxy]
        indices: bevy::render::mesh::Indices,
    ) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Consumes the mesh and returns a mesh without the vertex `indices` of the mesh.
/// (Alternatively, you can use [`Mesh::remove_indices`] to mutate an existing mesh in-place)

    #[lua(kind = "Method", output(proxy))]
    fn with_removed_indices(self) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Computes and returns the index data of the mesh as bytes.
/// This is used to transform the index data into a GPU friendly format.

    #[lua(kind = "Method")]
    fn get_index_buffer_bytes(&self) -> std::option::Option<&[u8]>;

"#,
			r#"
/// Counts all vertices of the mesh.
/// If the attributes have different vertex counts, the smallest is returned.

    #[lua(kind = "Method")]
    fn count_vertices(&self) -> usize;

"#,
			r#"
/// Computes and returns the vertex data of the mesh as bytes.
/// Therefore the attributes are located in the order of their [`MeshVertexAttribute::id`].
/// This is used to transform the vertex data into a GPU friendly format.
/// If the vertex attributes have different lengths, they are all truncated to
/// the length of the smallest.

    #[lua(kind = "Method")]
    fn get_vertex_buffer_data(&self) -> std::vec::Vec<u8std::alloc::Global>;

"#,
			r#"
/// Duplicates the vertex attributes so that no vertices are shared.
/// This can dramatically increase the vertex count, so make sure this is what you want.
/// Does nothing if no [Indices] are set.

    #[lua(kind = "Method")]
    fn duplicate_vertices(&mut self) -> ();

"#,
			r#"
/// Consumes the mesh and returns a mesh with no shared vertices.
/// This can dramatically increase the vertex count, so make sure this is what you want.
/// Does nothing if no [Indices] are set.
/// (Alternatively, you can use [`Mesh::duplicate_vertices`] to mutate an existing mesh in-place)

    #[lua(kind = "Method", output(proxy))]
    fn with_duplicated_vertices(self) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Calculates the [`Mesh::ATTRIBUTE_NORMAL`] of a mesh.
/// # Panics
/// Panics if [`Indices`] are set or [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3` or
/// if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
/// Consider calling [`Mesh::duplicate_vertices`] or export your mesh with normal attributes.

    #[lua(kind = "Method")]
    fn compute_flat_normals(&mut self) -> ();

"#,
			r#"
/// Consumes the mesh and returns a mesh with calculated [`Mesh::ATTRIBUTE_NORMAL`].
/// (Alternatively, you can use [`Mesh::compute_flat_normals`] to mutate an existing mesh in-place)
/// # Panics
/// Panics if [`Indices`] are set or [`Mesh::ATTRIBUTE_POSITION`] is not of type `float3` or
/// if the mesh has any other topology than [`PrimitiveTopology::TriangleList`].
/// Consider calling [`Mesh::with_duplicated_vertices`] or export your mesh with normal attributes.

    #[lua(kind = "Method", output(proxy))]
    fn with_computed_flat_normals(self) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Merges the [`Mesh`] data of `other` with `self`. The attributes and indices of `other` will be appended to `self`.
/// Note that attributes of `other` that don't exist on `self` will be ignored.
/// # Panics
/// Panics if the vertex attribute values of `other` are incompatible with `self`.
/// For example, [`VertexAttributeValues::Float32`] is incompatible with [`VertexAttributeValues::Float32x3`].

    #[lua(kind = "Method")]
    fn merge(&mut self, #[proxy] other: bevy::render::mesh::Mesh) -> ();

"#,
			r#"
/// Transforms the vertex positions, normals, and tangents of the mesh by the given [`Transform`].

    #[lua(kind = "Method", output(proxy))]
    fn transformed_by(
        self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Transforms the vertex positions, normals, and tangents of the mesh in place by the given [`Transform`].

    #[lua(kind = "Method")]
    fn transform_by(
        &mut self,
        #[proxy]
        transform: bevy::transform::components::Transform,
    ) -> ();

"#,
			r#"
/// Translates the vertex positions of the mesh by the given [`Vec3`].

    #[lua(kind = "Method", output(proxy))]
    fn translated_by(
        self,
        #[proxy]
        translation: bevy::math::Vec3,
    ) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Translates the vertex positions of the mesh in place by the given [`Vec3`].

    #[lua(kind = "Method")]
    fn translate_by(&mut self, #[proxy] translation: bevy::math::Vec3) -> ();

"#,
			r#"
/// Rotates the vertex positions, normals, and tangents of the mesh by the given [`Quat`].

    #[lua(kind = "Method", output(proxy))]
    fn rotated_by(self, #[proxy] rotation: bevy::math::Quat) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Rotates the vertex positions, normals, and tangents of the mesh in place by the given [`Quat`].

    #[lua(kind = "Method")]
    fn rotate_by(&mut self, #[proxy] rotation: bevy::math::Quat) -> ();

"#,
			r#"
/// Scales the vertex positions, normals, and tangents of the mesh by the given [`Vec3`].

    #[lua(kind = "Method", output(proxy))]
    fn scaled_by(self, #[proxy] scale: bevy::math::Vec3) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Scales the vertex positions, normals, and tangents of the mesh in place by the given [`Vec3`].

    #[lua(kind = "Method")]
    fn scale_by(&mut self, #[proxy] scale: bevy::math::Vec3) -> ();

"#,
			r#"
/// Whether this mesh has morph targets.

    #[lua(kind = "Method")]
    fn has_morph_targets(&self) -> bool;

"#,
			r#"
/// Sets the names of each morph target. This should correspond to the order of the morph targets in `set_morph_targets`.

    #[lua(kind = "Method")]
    fn set_morph_target_names(
        &mut self,
        names: std::vec::Vec<std::string::Stringstd::alloc::Global>,
    ) -> ();

"#,
			r#"
/// Consumes the mesh and returns a mesh with morph target names.
/// Names should correspond to the order of the morph targets in `set_morph_targets`.
/// (Alternatively, you can use [`Mesh::set_morph_target_names`] to mutate an existing mesh in-place)

    #[lua(kind = "Method", output(proxy))]
    fn with_morph_target_names(
        self,
        names: std::vec::Vec<std::string::Stringstd::alloc::Global>,
    ) -> bevy::render::mesh::Mesh;

"#,
			r#"
/// Gets a list of all morph target names, if they exist.

    #[lua(kind = "Method")]
    fn morph_target_names(&self) -> std::option::Option<&[std::string::String]>;

"#,
			r#"
/// Normalize joint weights so they sum to 1.

    #[lua(kind = "Method")]
    fn normalize_joint_weights(&mut self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::mesh::Mesh;

"#]
)]




pub struct LuaMesh{
    
    
        
    
        
    
        
    
        
    
        
    
    
}

    
/// An array of indices into the [`VertexAttributeValues`] for a mesh.

/// It describes the order in which the vertex attributes should be joined into faces.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::mesh::Indices",
functions[r#"
/// Returns the number of indices.

    #[lua(kind = "Method")]
    fn len(&self) -> usize;

"#,
			r#"
/// Returns `true` if there are no indices.

    #[lua(kind = "Method")]
    fn is_empty(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::mesh::Indices;

"#]
)]




pub struct LuaIndices{
    
}

    
/// Controls the [morph targets] for all child [`Handle<Mesh>`] entities. In most cases, [`MorphWeights`] should be considered

/// the "source of truth" when writing morph targets for meshes. However you can choose to write child [`MeshMorphWeights`]

/// if your situation requires more granularity. Just note that if you set [`MorphWeights`], it will overwrite child

/// [`MeshMorphWeights`] values.

/// This exists because Bevy's [`Mesh`] corresponds to a _single_ surface / material, whereas morph targets

/// as defined in the GLTF spec exist on "multi-primitive meshes" (where each primitive is its own surface with its own material).

/// Therefore in Bevy [`MorphWeights`] an a parent entity are the "canonical weights" from a GLTF perspective, which then

/// synchronized to child [`Handle<Mesh>`] / [`MeshMorphWeights`] (which correspond to "primitives" / "surfaces" from a GLTF perspective).

/// Add this to the parent of one or more [`Entities`](`Entity`) with a [`Handle<Mesh>`] with a [`MeshMorphWeights`].

/// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::mesh::morph::MorphWeights",
functions[r#"

    #[lua(kind = "Method")]
    fn weights(&self) -> &[f32];

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::mesh::morph::MorphWeights;

"#]
)]




pub struct LuaMorphWeights{
    
    
        
    
        
    
    
}

    
/// Control a specific [`Mesh`] instance's [morph targets]. These control the weights of

/// specific "mesh primitives" in scene formats like GLTF. They can be set manually, but

/// in most cases they should "automatically" synced by setting the [`MorphWeights`] component

/// on a parent entity.

/// See [`MorphWeights`] for more details on Bevy's morph target implementation.

/// Add this to an [`Entity`] with a [`Handle<Mesh>`] with a [`MorphAttributes`] set

/// to control individual weights of each morph target.

/// [morph targets]: https://en.wikipedia.org/wiki/Morph_target_animation


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::mesh::morph::MeshMorphWeights",
functions[r#"

    #[lua(kind = "Method")]
    fn weights(&self) -> &[f32];

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::mesh::morph::MeshMorphWeights;

"#]
)]




pub struct LuaMeshMorphWeights{
    
    
        
    
    
}

    
/// An axis-aligned bounding box, defined by:

/// - a center,

/// - the distances from the center to each faces along the axis,

/// the faces are orthogonal to the axis.

/// It is typically used as a component on an entity to represent the local space

/// occupied by this entity, with faces orthogonal to its local axis.

/// This component is notably used during "frustum culling", a process to determine

/// if an entity should be rendered by a [`Camera`] if its bounding box intersects

/// with the camera's [`Frustum`].

/// It will be added automatically by the systems in [`CalculateBounds`] to entities that:

/// - could be subject to frustum culling, for example with a [`Handle<Mesh>`]

/// or `Sprite` component,

/// - don't have the [`NoFrustumCulling`] component.

/// It won't be updated automatically if the space occupied by the entity changes,

/// for example if the vertex positions of a [`Mesh`] inside a `Handle<Mesh>` are

/// updated.

/// [`Camera`]: crate::camera::Camera

/// [`NoFrustumCulling`]: crate::view::visibility::NoFrustumCulling

/// [`CalculateBounds`]: crate::view::visibility::VisibilitySystems::CalculateBounds

/// [`Mesh`]: crate::mesh::Mesh

/// [`Handle<Mesh>`]: crate::mesh::Mesh


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::primitives::Aabb",
functions[r#"

    #[lua(kind = "Function", output(proxy))]
    fn from_min_max(
        #[proxy]
        minimum: bevy::math::Vec3,
        #[proxy]
        maximum: bevy::math::Vec3,
    ) -> bevy::render::primitives::Aabb;

"#,
			r#"
/// Calculate the relative radius of the AABB with respect to a plane

    #[lua(kind = "Method")]
    fn relative_radius(
        &self,
        #[proxy]
        p_normal: &bevy_math::Vec3A,
        #[proxy]
        model: &bevy_math::Mat3A,
    ) -> f32;

"#,
			r#"

    #[lua(kind = "Method", output(proxy))]
    fn min(&self) -> bevy::math::Vec3A;

"#,
			r#"

    #[lua(kind = "Method", output(proxy))]
    fn max(&self) -> bevy::math::Vec3A;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::primitives::Aabb;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &primitives::Aabb) -> bool;

"#]
)]




pub struct LuaAabb{
    
    
    
}

    
/// A region of 3D space defined by the intersection of 6 [`HalfSpace`]s.

/// Frustums are typically an apex-truncated square pyramid (a pyramid without the top) or a cuboid.

/// Half spaces are ordered left, right, top, bottom, near, far. The normal vectors

/// of the half-spaces point towards the interior of the frustum.

/// A frustum component is used on an entity with a [`Camera`] component to

/// determine which entities will be considered for rendering by this camera.

/// All entities with an [`Aabb`] component that are not contained by (or crossing

/// the boundary of) the frustum will not be rendered, and not be used in rendering computations.

/// This process is called frustum culling, and entities can opt out of it using

/// the [`NoFrustumCulling`] component.

/// The frustum component is typically added from a bundle, either the `Camera2dBundle`

/// or the `Camera3dBundle`.

/// It is usually updated automatically by [`update_frusta`] from the

/// [`CameraProjection`] component and [`GlobalTransform`] of the camera entity.

/// [`Camera`]: crate::camera::Camera

/// [`NoFrustumCulling`]: crate::view::visibility::NoFrustumCulling

/// [`update_frusta`]: crate::view::visibility::update_frusta

/// [`CameraProjection`]: crate::camera::CameraProjection

/// [`GlobalTransform`]: bevy_transform::components::GlobalTransform


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::primitives::Frustum",
functions[r#"
/// Returns a frustum derived from `view_projection`.

    #[lua(kind = "Function", output(proxy))]
    fn from_view_projection(
        #[proxy]
        view_projection: &bevy_math::Mat4,
    ) -> bevy::render::primitives::Frustum;

"#,
			r#"
/// Returns a frustum derived from `view_projection`,
/// but with a custom far plane.

    #[lua(kind = "Function", output(proxy))]
    fn from_view_projection_custom_far(
        #[proxy]
        view_projection: &bevy_math::Mat4,
        #[proxy]
        view_translation: &bevy_math::Vec3,
        #[proxy]
        view_backward: &bevy_math::Vec3,
        far: f32,
    ) -> bevy::render::primitives::Frustum;

"#,
			r#"
/// Returns a frustum derived from `view_projection`,
/// without a far plane.

    #[lua(kind = "Function", output(proxy))]
    fn from_view_projection_no_far(
        #[proxy]
        view_projection: &bevy_math::Mat4,
    ) -> bevy::render::primitives::Frustum;

"#,
			r#"
/// Checks if an Oriented Bounding Box (obb) intersects the frustum.

    #[lua(kind = "Method")]
    fn intersects_obb(
        &self,
        #[proxy]
        aabb: &primitives::Aabb,
        #[proxy]
        model_to_world: &bevy_math::Affine3A,
        intersect_near: bool,
        intersect_far: bool,
    ) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::primitives::Frustum;

"#]
)]




pub struct LuaFrustum{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::primitives::CubemapFrusta",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::primitives::CubemapFrusta;

"#]
)]




pub struct LuaCubemapFrusta{
    
    
    
}

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::primitives::CascadesFrusta",
functions[]
)]




pub struct LuaCascadesFrusta{
    
    
    
}

    
/// Defines where the asset will be used.

/// If an asset is set to the `RENDER_WORLD` but not the `MAIN_WORLD`, the asset will be

/// unloaded from the asset server once it's been extracted and prepared in the render world.

/// Unloading the asset saves on memory, as for most cases it is no longer necessary to keep

/// it in RAM once it's been uploaded to the GPU's VRAM. However, this means you can no longer

/// access the asset from the CPU (via the `Assets<T>` resource) once unloaded (without re-loading it).

/// If you never need access to the asset from the CPU past the first frame it's loaded on,

/// or only need very infrequent access, then set this to `RENDER_WORLD`. Otherwise, set this to

/// `RENDER_WORLD | MAIN_WORLD`.

/// If you have an asset that doesn't actually need to end up in the render world, like an Image

/// that will be decoded into another Image asset, use `MAIN_WORLD` only.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::render_asset::RenderAssetUsages",
functions[r#"
/// Get a flags value with all bits unset.

    #[lua(kind = "Function", output(proxy))]
    fn empty() -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// Get a flags value with all known bits set.

    #[lua(kind = "Function", output(proxy))]
    fn all() -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// Get the underlying bits value.
/// The returned value is exactly the bits set in this flags value.

    #[lua(kind = "Method")]
    fn bits(&self) -> u8;

"#,
			r#"
/// Convert from a bits value, unsetting any unknown bits.

    #[lua(kind = "Function", output(proxy))]
    fn from_bits_truncate(bits: u8) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// Convert from a bits value exactly.

    #[lua(kind = "Function", output(proxy))]
    fn from_bits_retain(bits: u8) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// Whether all bits in this flags value are unset.

    #[lua(kind = "Method")]
    fn is_empty(&self) -> bool;

"#,
			r#"
/// Whether all known bits in this flags value are set.

    #[lua(kind = "Method")]
    fn is_all(&self) -> bool;

"#,
			r#"
/// Whether any set bits in a source flags value are also set in a target flags value.

    #[lua(kind = "Method")]
    fn intersects(
        &self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bool;

"#,
			r#"
/// Whether all set bits in a source flags value are also set in a target flags value.

    #[lua(kind = "Method")]
    fn contains(
        &self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bool;

"#,
			r#"
/// The bitwise or (`|`) of the bits in two flags values.

    #[lua(kind = "Method")]
    fn insert(
        &mut self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> ();

"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `remove` won't truncate `other`, but the `!` operator will.

    #[lua(kind = "Method")]
    fn remove(
        &mut self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> ();

"#,
			r#"
/// The bitwise exclusive-or (`^`) of the bits in two flags values.

    #[lua(kind = "Method")]
    fn toggle(
        &mut self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> ();

"#,
			r#"
/// Call `insert` when `value` is `true` or `remove` when `value` is `false`.

    #[lua(kind = "Method")]
    fn set(
        &mut self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
        value: bool,
    ) -> ();

"#,
			r#"
/// The bitwise and (`&`) of the bits in two flags values.

    #[lua(kind = "Method", output(proxy))]
    fn intersection(
        self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// The bitwise or (`|`) of the bits in two flags values.

    #[lua(kind = "Method", output(proxy))]
    fn union(
        self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `difference` won't truncate `other`, but the `!` operator will.

    #[lua(kind = "Method", output(proxy))]
    fn difference(
        self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// The bitwise exclusive-or (`^`) of the bits in two flags values.

    #[lua(kind = "Method", output(proxy))]
    fn symmetric_difference(
        self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// The bitwise negation (`!`) of the bits in a flags value, truncating the result.

    #[lua(kind = "Method", output(proxy))]
    fn complement(self) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"
/// The intersection of a source flags value with the complement of a target flags value (`&!`).
/// This method is not equivalent to `self & !other` when `other` has unknown bits set.
/// `difference` won't truncate `other`, but the `!` operator will.

    #[lua(
        as_trait = "std::ops::Sub",
        kind = "Function",
        output(proxy),
        composite = "sub",
        metamethod = "Sub",
    )]
    fn sub(
        self,
        #[proxy]
        other: bevy::render::render_asset::RenderAssetUsages,
    ) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::render_asset::RenderAssetUsages;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &render_asset::RenderAssetUsages) -> bool;

"#]
)]



pub struct LuaRenderAssetUsages(
    
    
        
    
    
);

    

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::texture::Image",
functions[r#"
/// Returns the width of a 2D image.

    #[lua(kind = "Method")]
    fn width(&self) -> u32;

"#,
			r#"
/// Returns the height of a 2D image.

    #[lua(kind = "Method")]
    fn height(&self) -> u32;

"#,
			r#"
/// Returns the size of a 2D image as f32.

    #[lua(kind = "Method", output(proxy))]
    fn size_f32(&self) -> bevy::math::Vec2;

"#,
			r#"
/// Returns the size of a 2D image.

    #[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy::math::UVec2;

"#,
			r#"
/// Takes a 2D image containing vertically stacked images of the same size, and reinterprets
/// it as a 2D array texture, where each of the stacked images becomes one layer of the
/// array. This is primarily for use with the `texture2DArray` shader uniform type.
/// # Panics
/// Panics if the texture is not 2D, has more than one layers or is not evenly dividable into
/// the `layers`.

    #[lua(kind = "Method")]
    fn reinterpret_stacked_2d_as_array(&mut self, layers: u32) -> ();

"#,
			r#"
/// Whether the texture format is compressed or uncompressed

    #[lua(kind = "Method")]
    fn is_compressed(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::texture::Image;

"#]
)]




pub struct LuaImage{
    
    
    
}

    
/// Describes which rendering layers an entity belongs to.

/// Cameras with this component will only render entities with intersecting

/// layers.

/// There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may

/// belong to one or more layers, or no layer at all.

/// The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.

/// An entity with this component without any layers is invisible.

/// Entities without this component belong to layer `0`.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::RenderLayers",
functions[r#"
/// Create a new `RenderLayers` belonging to the given layer.

    #[lua(kind = "Function", output(proxy))]
    fn layer(n: u8) -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"
/// Create a new `RenderLayers` that belongs to all layers.

    #[lua(kind = "Function", output(proxy))]
    fn all() -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"
/// Create a new `RenderLayers` that belongs to no layers.

    #[lua(kind = "Function", output(proxy))]
    fn none() -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"
/// Add the given layer.
/// This may be called multiple times to allow an entity to belong
/// to multiple rendering layers. The maximum layer is `TOTAL_LAYERS - 1`.
/// # Panics
/// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.

    #[lua(kind = "Method", output(proxy))]
    fn with(self, layer: u8) -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"
/// Removes the given rendering layer.
/// # Panics
/// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.

    #[lua(kind = "Method", output(proxy))]
    fn without(self, layer: u8) -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"
/// Determine if a `RenderLayers` intersects another.
/// `RenderLayers`s intersect if they share any common layers.
/// A `RenderLayers` with no layers will not match any other
/// `RenderLayers`, even another with no layers.

    #[lua(kind = "Method")]
    fn intersects(
        &self,
        #[proxy]
        other: &view::visibility::render_layers::RenderLayers,
    ) -> bool;

"#,
			r#"
/// get the bitmask representation of the contained layers

    #[lua(kind = "Method")]
    fn bits(&self) -> u32;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::visibility::RenderLayers;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &view::visibility::render_layers::RenderLayers) -> bool;

"#]
)]



pub struct LuaRenderLayers(
    
    
        
    
    
);

    
/// User indication of whether an entity is visible. Propagates down the entity hierarchy.

/// If an entity is hidden in this way, all [`Children`] (and all of their children and so on) who

/// are set to [`Inherited`](Self::Inherited) will also be hidden.

/// This is done by the `visibility_propagate_system` which uses the entity hierarchy and

/// `Visibility` to set the values of each entity's [`InheritedVisibility`] component.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::Visibility",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::visibility::Visibility;

"#]
)]




pub struct LuaVisibility{
    
}

    
/// Whether or not an entity is visible in the hierarchy.

/// This will not be accurate until [`VisibilityPropagate`] runs in the [`PostUpdate`] schedule.

/// If this is false, then [`ViewVisibility`] should also be false.

/// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::InheritedVisibility",
functions[r#"
/// Returns `true` if the entity is visible in the hierarchy.
/// Otherwise, returns `false`.

    #[lua(kind = "Method")]
    fn get(self) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::visibility::InheritedVisibility;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &view::visibility::InheritedVisibility) -> bool;

"#]
)]



pub struct LuaInheritedVisibility(
    
    
        
    
    
);

    
/// Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering.

/// Each frame, this will be reset to `false` during [`VisibilityPropagate`] systems in [`PostUpdate`].

/// Later in the frame, systems in [`CheckVisibility`] will mark any visible entities using [`ViewVisibility::set`].

/// Because of this, values of this type will be marked as changed every frame, even when they do not change.

/// If you wish to add custom visibility system that sets this value, make sure you add it to the [`CheckVisibility`] set.

/// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate

/// [`CheckVisibility`]: VisibilitySystems::CheckVisibility


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::ViewVisibility",
functions[r#"
/// Returns `true` if the entity is visible in any view.
/// Otherwise, returns `false`.

    #[lua(kind = "Method")]
    fn get(self) -> bool;

"#,
			r#"
/// Sets the visibility to `true`. This should not be considered reversible for a given frame,
/// as this component tracks whether or not the entity visible in _any_ view.
/// This will be automatically reset to `false` every frame in [`VisibilityPropagate`] and then set
/// to the proper value in [`CheckVisibility`].
/// You should only manually set this if you are defining a custom visibility system,
/// in which case the system should be placed in the [`CheckVisibility`] set.
/// For normal user-defined entity visibility, see [`Visibility`].
/// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate
/// [`CheckVisibility`]: VisibilitySystems::CheckVisibility

    #[lua(kind = "Method")]
    fn set(&mut self) -> ();

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::visibility::ViewVisibility;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &view::visibility::ViewVisibility) -> bool;

"#]
)]



pub struct LuaViewVisibility(
    
    
        
    
    
);

    
/// Use this component to opt-out of built-in frustum culling for entities, see

/// [`Frustum`].

/// It can be used for example:

/// - when a [`Mesh`] is updated but its [`Aabb`] is not, which might happen with animations,

/// - when using some light effects, like wanting a [`Mesh`] out of the [`Frustum`]

/// to appear in the reflection of a [`Mesh`] within.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::NoFrustumCulling",
functions[]
)]




pub struct LuaNoFrustumCulling{
    
    
    
}

    
/// Collection of entities visible from the current view.

/// This component contains all entities which are visible from the currently

/// rendered view. The collection is updated automatically by the [`VisibilitySystems::CheckVisibility`]

/// system set, and renderers can use it to optimize rendering of a particular view, to

/// prevent drawing items not visible from that view.

/// This component is intended to be attached to the same entity as the [`Camera`] and

/// the [`Frustum`] defining the view.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::visibility::VisibleEntities",
functions[r#"

    #[lua(kind = "Method")]
    fn len(&self) -> usize;

"#,
			r#"

    #[lua(kind = "Method")]
    fn is_empty(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::visibility::VisibleEntities;

"#]
)]




pub struct LuaVisibleEntities{
    
    
    
}

    
/// Configuration resource for [Multi-Sample Anti-Aliasing](https://en.wikipedia.org/wiki/Multisample_anti-aliasing).

/// The number of samples to run for Multi-Sample Anti-Aliasing. Higher numbers result in

/// smoother edges.

/// Defaults to 4 samples.

/// Note that web currently only supports 1 or 4 samples.

/// # Example

/// ```

/// # use bevy_app::prelude::App;

/// # use bevy_render::prelude::Msaa;

/// App::new()

///     .insert_resource(Msaa::default())

///     .run();

/// ```


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::Msaa",
functions[r#"

    #[lua(kind = "Method")]
    fn samples(&self) -> u32;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::Msaa;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &view::Msaa) -> bool;

"#]
)]




pub struct LuaMsaa{
    
}

    
/// Configures basic color grading parameters to adjust the image appearance. Grading is applied just before/after tonemapping for a given [`Camera`](crate::camera::Camera) entity.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::render::view::ColorGrading",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::render::view::ColorGrading;

"#]
)]




pub struct LuaColorGrading{
    
    
    
}




crate::impl_tealr_generic!(pub(crate) struct T);


#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaColor", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaColor>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
                instances.add_instance("LuaAabb", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaAabb>::new)?;
            
         
            
                instances.add_instance("LuaFrustum", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaFrustum>::new)?;
            
         
            
         
            
         
            
                instances.add_instance("LuaRenderAssetUsages", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaRenderAssetUsages>::new)?;
            
         
            
         
            
                instances.add_instance("LuaRenderLayers", 
                                bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaRenderLayers>::new)?;
            
         
            
         
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyRenderAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyRenderAPIProvider {
        type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new("BevyRenderAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaViewport>()
                
            
                .process_type::<LuaExposure>()
                
            
                .process_type::<LuaCamera>()
                
            
                .process_type::<LuaCameraRenderGraph>()
                
            
                .process_type::<LuaRenderTarget>()
                
            
                .process_type::<LuaNormalizedRenderTarget>()
                
            
                .process_type::<LuaCameraMainTextureUsages>()
                
            
                .process_type::<LuaClearColorConfig>()
                
            
                .process_type::<LuaClearColor>()
                
            
                .process_type::<LuaManualTextureViewHandle>()
                
            
                .process_type::<LuaProjection>()
                
            
                .process_type::<LuaPerspectiveProjection>()
                
            
                .process_type::<LuaScalingMode>()
                
            
                .process_type::<LuaOrthographicProjection>()
                
            
                .process_type::<LuaColor>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaColor>>()
                
            
                .process_type::<LuaGlobalsUniform>()
                
            
                .process_type::<LuaSkinnedMesh>()
                
            
                .process_type::<LuaMesh>()
                
            
                .process_type::<LuaIndices>()
                
            
                .process_type::<LuaMorphWeights>()
                
            
                .process_type::<LuaMeshMorphWeights>()
                
            
                .process_type::<LuaAabb>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaAabb>>()
                
            
                .process_type::<LuaFrustum>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaFrustum>>()
                
            
                .process_type::<LuaCubemapFrusta>()
                
            
                .process_type::<LuaCascadesFrusta>()
                
            
                .process_type::<LuaRenderAssetUsages>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaRenderAssetUsages>>()
                
            
                .process_type::<LuaImage>()
                
            
                .process_type::<LuaRenderLayers>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaRenderLayers>>()
                
            
                .process_type::<LuaVisibility>()
                
            
                .process_type::<LuaInheritedVisibility>()
                
            
                .process_type::<LuaViewVisibility>()
                
            
                .process_type::<LuaNoFrustumCulling>()
                
            
                .process_type::<LuaVisibleEntities>()
                
            
                .process_type::<LuaMsaa>()
                
            
                .process_type::<LuaColorGrading>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        
        app.register_foreign_lua_type::<bevy::render::camera::Viewport>();
        
        app.register_foreign_lua_type::<bevy::render::camera::Exposure>();
        
        app.register_foreign_lua_type::<bevy::render::camera::Camera>();
        
        app.register_foreign_lua_type::<bevy::render::camera::CameraRenderGraph>();
        
        app.register_foreign_lua_type::<bevy::render::camera::RenderTarget>();
        
        app.register_foreign_lua_type::<bevy::render::camera::NormalizedRenderTarget>();
        
        app.register_foreign_lua_type::<bevy::render::camera::CameraMainTextureUsages>();
        
        app.register_foreign_lua_type::<bevy::render::camera::ClearColorConfig>();
        
        app.register_foreign_lua_type::<bevy::render::camera::ClearColor>();
        
        app.register_foreign_lua_type::<bevy::render::camera::ManualTextureViewHandle>();
        
        app.register_foreign_lua_type::<bevy::render::camera::Projection>();
        
        app.register_foreign_lua_type::<bevy::render::camera::PerspectiveProjection>();
        
        app.register_foreign_lua_type::<bevy::render::camera::ScalingMode>();
        
        app.register_foreign_lua_type::<bevy::render::camera::OrthographicProjection>();
        
        app.register_foreign_lua_type::<bevy::render::color::Color>();
        
        app.register_foreign_lua_type::<bevy::render::globals::GlobalsUniform>();
        
        app.register_foreign_lua_type::<bevy::render::mesh::skinning::SkinnedMesh>();
        
        app.register_foreign_lua_type::<bevy::render::mesh::Mesh>();
        
        app.register_foreign_lua_type::<bevy::render::mesh::Indices>();
        
        app.register_foreign_lua_type::<bevy::render::mesh::morph::MorphWeights>();
        
        app.register_foreign_lua_type::<bevy::render::mesh::morph::MeshMorphWeights>();
        
        app.register_foreign_lua_type::<bevy::render::primitives::Aabb>();
        
        app.register_foreign_lua_type::<bevy::render::primitives::Frustum>();
        
        app.register_foreign_lua_type::<bevy::render::primitives::CubemapFrusta>();
        
        app.register_foreign_lua_type::<bevy::render::primitives::CascadesFrusta>();
        
        app.register_foreign_lua_type::<bevy::render::render_asset::RenderAssetUsages>();
        
        app.register_foreign_lua_type::<bevy::render::texture::Image>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::RenderLayers>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::Visibility>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::InheritedVisibility>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::ViewVisibility>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::NoFrustumCulling>();
        
        app.register_foreign_lua_type::<bevy::render::view::visibility::VisibleEntities>();
        
        app.register_foreign_lua_type::<bevy::render::view::Msaa>();
        
        app.register_foreign_lua_type::<bevy::render::view::ColorGrading>();
        
    }
}
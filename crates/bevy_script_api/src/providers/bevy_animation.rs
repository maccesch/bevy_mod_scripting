#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file


use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_render::*;

use super::bevy_time::*;

use super::bevy_transform::*;



extern crate self as bevy_script_api;





    
/// List of keyframes for one of the attribute of a [`Transform`].


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::Keyframes",
functions[r#"
/// Returns the number of keyframes.

    #[lua(kind = "Method")]
    fn len(&self) -> usize;

"#,
			r#"
/// Returns true if the number of keyframes is zero.

    #[lua(kind = "Method")]
    fn is_empty(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::prelude::Keyframes;

"#]
)]




pub struct LuaKeyframes{
    
}

    
/// Describes how an attribute of a [`Transform`] or [`MorphWeights`] should be animated.

/// `keyframe_timestamps` and `keyframes` should have the same length.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::VariableCurve",
functions[r#"
/// Find the index of the keyframe at or before the current time.
/// Returns [`None`] if the curve is finished or not yet started.
/// To be more precise, this returns [`None`] if the frame is at or past the last keyframe:
/// we cannot get the *next* keyframe to interpolate to in that case.

    #[lua(kind = "Method")]
    fn find_current_keyframe(&self, seek_time: f32) -> std::option::Option<usize>;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::prelude::VariableCurve;

"#]
)]




pub struct LuaVariableCurve{
    
    
    
}

    
/// Interpolation method to use between keyframes.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::Interpolation",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::prelude::Interpolation;

"#]
)]




pub struct LuaInterpolation{
    
}

    
/// Path to an entity, with [`Name`]s. Each entity in a path must have a name.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::EntityPath",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::prelude::EntityPath;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &EntityPath) -> bool;

"#]
)]




pub struct LuaEntityPath{
    
    
    
}

    
/// A list of [`VariableCurve`], and the [`EntityPath`] to which they apply.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::AnimationClip",
functions[r#"
/// Duration of the clip, represented in seconds

    #[lua(kind = "Method")]
    fn duration(&self) -> f32;

"#,
			r#"
/// Add a [`VariableCurve`] to an [`EntityPath`].

    #[lua(kind = "Method")]
    fn add_curve_to_path(
        &mut self,
        #[proxy]
        path: bevy::animation::prelude::EntityPath,
        #[proxy]
        curve: bevy::animation::prelude::VariableCurve,
    ) -> ();

"#,
			r#"
/// Whether this animation clip can run on entity with given [`Name`].

    #[lua(kind = "Method")]
    fn compatible_with(&self, #[proxy] name: &bevy_core::Name) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::prelude::AnimationClip;

"#]
)]




pub struct LuaAnimationClip{
    
    
        
    
        
    
        
    
    
}

    
/// Repetition behavior of an animation.


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::RepeatAnimation",
functions[r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::animation::RepeatAnimation;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &RepeatAnimation) -> bool;

"#]
)]




pub struct LuaRepeatAnimation{
    
}

    
/// Animation controls


#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::animation::prelude::AnimationPlayer",
functions[r#"
/// Check if the playing animation has finished, according to the repetition behavior.

    #[lua(kind = "Method")]
    fn is_finished(&self) -> bool;

"#,
			r#"
/// Repetition behavior of the animation.

    #[lua(kind = "Method", output(proxy))]
    fn repeat_mode(&self) -> bevy::animation::RepeatAnimation;

"#,
			r#"
/// Number of times the animation has completed.

    #[lua(kind = "Method")]
    fn completions(&self) -> u32;

"#,
			r#"
/// Check if the animation is playing in reverse.

    #[lua(kind = "Method")]
    fn is_playback_reversed(&self) -> bool;

"#,
			r#"
/// Pause the animation

    #[lua(kind = "Method")]
    fn pause(&mut self) -> ();

"#,
			r#"
/// Unpause the animation

    #[lua(kind = "Method")]
    fn resume(&mut self) -> ();

"#,
			r#"
/// Is the animation paused

    #[lua(kind = "Method")]
    fn is_paused(&self) -> bool;

"#,
			r#"
/// Speed of the animation playback

    #[lua(kind = "Method")]
    fn speed(&self) -> f32;

"#,
			r#"
/// Time elapsed playing the animation

    #[lua(kind = "Method")]
    fn elapsed(&self) -> f32;

"#,
			r#"
/// Seek time inside of the animation. Always within the range [0.0, clip duration].

    #[lua(kind = "Method")]
    fn seek_time(&self) -> f32;

"#,
			r#"
/// Reset the animation to its initial state, as if no time has elapsed.

    #[lua(kind = "Method")]
    fn replay(&mut self) -> ();

"#]
)]




pub struct LuaAnimationPlayer{
    
    
        
    
        
    
        
    
    
}




crate::impl_tealr_generic!(pub(crate) struct T);


#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
         
            
         
            
         
            
         
            
         
            
         
            
         
            
        
        Ok(())
    }
}

pub struct BevyAnimationAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyAnimationAPIProvider {
        type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
        type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(&mut self, ctx: &mut Self::APITarget) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new("BevyAnimationAPI", |tw| {
            tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaKeyframes>()
                
            
                .process_type::<LuaVariableCurve>()
                
            
                .process_type::<LuaInterpolation>()
                
            
                .process_type::<LuaEntityPath>()
                
            
                .process_type::<LuaAnimationClip>()
                
            
                .process_type::<LuaRepeatAnimation>()
                
            
                .process_type::<LuaAnimationPlayer>()
                
            
            }
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        
        app.register_foreign_lua_type::<bevy::animation::prelude::Keyframes>();
        
        app.register_foreign_lua_type::<bevy::animation::prelude::VariableCurve>();
        
        app.register_foreign_lua_type::<bevy::animation::prelude::Interpolation>();
        
        app.register_foreign_lua_type::<bevy::animation::prelude::EntityPath>();
        
        app.register_foreign_lua_type::<bevy::animation::prelude::AnimationClip>();
        
        app.register_foreign_lua_type::<bevy::animation::RepeatAnimation>();
        
        app.register_foreign_lua_type::<bevy::animation::prelude::AnimationPlayer>();
        
    }
}
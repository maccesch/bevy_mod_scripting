#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file

extern crate self as bevy_script_api;
use crate::lua::RegisterForeignLuaType;

/// A type that can represent owned, mutable platform-native strings, but is

/// cheaply inter-convertible with Rust strings.

/// The need for this type arises from the fact that:

/// * On Unix systems, strings are often arbitrary sequences of non-zero

///   bytes, in many cases interpreted as UTF-8.

/// * On Windows, strings are often arbitrary sequences of non-zero 16-bit

///   values, interpreted as UTF-16 when it is valid to do so.

/// * In Rust, strings are always valid UTF-8, which may contain zeros.

/// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust

/// and platform-native string values, and in particular allowing a Rust string

/// to be converted into an "OS" string with no cost if possible. A consequence

/// of this is that `OsString` instances are *not* `NUL` terminated; in order

/// to pass to e.g., Unix system call, you should create a [`CStr`].

/// `OsString` is to <code>&[OsStr]</code> as [`String`] is to <code>&[str]</code>: the former

/// in each pair are owned strings; the latter are borrowed

/// references.

/// Note, `OsString` and [`OsStr`] internally do not necessarily hold strings in

/// the form native to the platform; While on Unix, strings are stored as a

/// sequence of 8-bit values, on Windows, where strings are 16-bit value based

/// as just discussed, strings are also actually stored as a sequence of 8-bit

/// values, encoded in a less-strict variant of UTF-8. This is useful to

/// understand when handling capacity and length values.

/// # Capacity of `OsString`

/// Capacity uses units of UTF-8 bytes for OS strings which were created from valid unicode, and

/// uses units of bytes in an unspecified encoding for other contents. On a given target, all

/// `OsString` and `OsStr` values use the same units for capacity, so the following will work:

/// ```

/// use std::ffi::{OsStr, OsString};

/// fn concat_os_strings(a: &OsStr, b: &OsStr) -> OsString {

///     let mut ret = OsString::with_capacity(a.len() + b.len()); // This will allocate

///     ret.push(a); // This will not allocate further

///     ret.push(b); // This will not allocate further

///     ret

/// }

/// ```

/// # Creating an `OsString`

/// **From a Rust string**: `OsString` implements

/// <code>[From]<[String]></code>, so you can use <code>my_string.[into]\()</code> to

/// create an `OsString` from a normal Rust string.

/// **From slices:** Just like you can start with an empty Rust

/// [`String`] and then [`String::push_str`] some <code>&[str]</code>

/// sub-string slices into it, you can create an empty `OsString` with

/// the [`OsString::new`] method and then push string slices into it with the

/// [`OsString::push`] method.

/// # Extracting a borrowed reference to the whole OS string

/// You can use the [`OsString::as_os_str`] method to get an <code>&[OsStr]</code> from

/// an `OsString`; this is effectively a borrowed reference to the

/// whole string.

/// # Conversions

/// See the [module's toplevel documentation about conversions][conversions] for a discussion on

/// the traits which `OsString` implements for [conversions] from/to native representations.

/// [`CStr`]: crate::ffi::CStr

/// [conversions]: super#conversions

/// [into]: Into::into

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::ffi::OsString",
functions[]
)]

pub struct OsString {}

/// An owned, mutable path (akin to [`String`]).

/// This type provides methods like [`push`] and [`set_extension`] that mutate

/// the path in place. It also implements [`Deref`] to [`Path`], meaning that

/// all methods on [`Path`] slices are available on `PathBuf` values as well.

/// [`push`]: PathBuf::push

/// [`set_extension`]: PathBuf::set_extension

/// More details about the overall approach can be found in

/// the [module documentation](self).

/// # Examples

/// You can use [`push`] to build up a `PathBuf` from

/// components:

/// ```

/// use std::path::PathBuf;

/// let mut path = PathBuf::new();

/// path.push(r"C:\");

/// path.push("windows");

/// path.push("system32");

/// path.set_extension("dll");

/// ```

/// However, [`push`] is best used for dynamic situations. This is a better way

/// to do this when you know all of the components ahead of time:

/// ```

/// use std::path::PathBuf;

/// let path: PathBuf = [r"C:\", "windows", "system32.dll"].iter().collect();

/// ```

/// We can still do better than this! Since these are all strings, we can use

/// `From::from`:

/// ```

/// use std::path::PathBuf;

/// let path = PathBuf::from(r"C:\windows\system32.dll");

/// ```

/// Which method works best depends on what kind of situation you're in.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::path::PathBuf",
functions[]
)]

pub struct PathBuf {}

/// A measurement of a monotonically nondecreasing clock.

/// Opaque and useful only with [`Duration`].

/// Instants are always guaranteed, barring [platform bugs], to be no less than any previously

/// measured instant when created, and are often useful for tasks such as measuring

/// benchmarks or timing how long an operation takes.

/// Note, however, that instants are **not** guaranteed to be **steady**. In other

/// words, each tick of the underlying clock might not be the same length (e.g.

/// some seconds may be longer than others). An instant may jump forwards or

/// experience time dilation (slow down or speed up), but it will never go

/// backwards.

/// As part of this non-guarantee it is also not specified whether system suspends count as

/// elapsed time or not. The behavior varies across platforms and rust versions.

/// Instants are opaque types that can only be compared to one another. There is

/// no method to get "the number of seconds" from an instant. Instead, it only

/// allows measuring the duration between two instants (or comparing two

/// instants).

/// The size of an `Instant` struct may vary depending on the target operating

/// system.

/// Example:

/// ```no_run

/// use std::time::{Duration, Instant};

/// use std::thread::sleep;

/// fn main() {

///    let now = Instant::now();

///    // we sleep for 2 seconds

///    sleep(Duration::new(2, 0));

///    // it prints '2'

///    println!("{}", now.elapsed().as_secs());

/// }

/// ```

/// [platform bugs]: Instant#monotonicity

/// # OS-specific behaviors

/// An `Instant` is a wrapper around system-specific types and it may behave

/// differently depending on the underlying operating system. For example,

/// the following snippet is fine on Linux but panics on macOS:

/// ```no_run

/// use std::time::{Instant, Duration};

/// let now = Instant::now();

/// let max_seconds = u64::MAX / 1_000_000_000;

/// let duration = Duration::new(max_seconds, 0);

/// println!("{:?}", now + duration);

/// ```

/// # Underlying System calls

/// The following system calls are [currently] being used by `now()` to find out

/// the current time:

/// |  Platform |               System call                                            |

/// |-----------|----------------------------------------------------------------------|

/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |

/// | UNIX      | [clock_gettime (Monotonic Clock)]                                    |

/// | Darwin    | [clock_gettime (Monotonic Clock)]                                    |

/// | VXWorks   | [clock_gettime (Monotonic Clock)]                                    |

/// | SOLID     | `get_tim`                                                            |

/// | WASI      | [__wasi_clock_time_get (Monotonic Clock)]                            |

/// | Windows   | [QueryPerformanceCounter]                                            |

/// [currently]: crate::io#platform-specific-behavior

/// [QueryPerformanceCounter]: https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter

/// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time

/// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode

/// [__wasi_clock_time_get (Monotonic Clock)]: https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#clock_time_get

/// [clock_gettime (Monotonic Clock)]: https://linux.die.net/man/3/clock_gettime

/// **Disclaimer:** These system calls might change over time.

/// > Note: mathematical operations like [`add`] may panic if the underlying

/// > structure cannot represent the new point in time.

/// [`add`]: Instant::add

/// ## Monotonicity

/// On all platforms `Instant` will try to use an OS API that guarantees monotonic behavior

/// if available, which is the case for all [tier 1] platforms.

/// In practice such guarantees are – under rare circumstances – broken by hardware, virtualization

/// or operating system bugs. To work around these bugs and platforms not offering monotonic clocks

/// [`duration_since`], [`elapsed`] and [`sub`] saturate to zero. In older Rust versions this

/// lead to a panic instead. [`checked_duration_since`] can be used to detect and handle situations

/// where monotonicity is violated, or `Instant`s are subtracted in the wrong order.

/// This workaround obscures programming errors where earlier and later instants are accidentally

/// swapped. For this reason future rust versions may reintroduce panics.

/// [tier 1]: https://doc.rust-lang.org/rustc/platform-support.html

/// [`duration_since`]: Instant::duration_since

/// [`elapsed`]: Instant::elapsed

/// [`sub`]: Instant::sub

/// [`checked_duration_since`]: Instant::checked_duration_since

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="bevy::utils::Instant",
functions[]
)]

pub struct Instant();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU8>` is the same size as `u8`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU8>>(), size_of::<u8>());

/// ```

/// # Layout

///`NonZeroU8` is guaranteed to have the same layout and bit validity as `u8`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU8>` is guaranteed to be compatible with `u8`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU8` and `Option<NonZeroU8>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU8;

///assert_eq!(size_of::<NonZeroU8>(), size_of::<Option<NonZeroU8>>());

///assert_eq!(align_of::<NonZeroU8>(), align_of::<Option<NonZeroU8>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU8",
functions[]
)]

pub struct NonZeroU8();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU16>` is the same size as `u16`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU16>>(), size_of::<u16>());

/// ```

/// # Layout

///`NonZeroU16` is guaranteed to have the same layout and bit validity as `u16`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU16>` is guaranteed to be compatible with `u16`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU16` and `Option<NonZeroU16>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU16;

///assert_eq!(size_of::<NonZeroU16>(), size_of::<Option<NonZeroU16>>());

///assert_eq!(align_of::<NonZeroU16>(), align_of::<Option<NonZeroU16>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU16",
functions[]
)]

pub struct NonZeroU16();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU32>` is the same size as `u32`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU32>>(), size_of::<u32>());

/// ```

/// # Layout

///`NonZeroU32` is guaranteed to have the same layout and bit validity as `u32`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU32>` is guaranteed to be compatible with `u32`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU32` and `Option<NonZeroU32>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU32;

///assert_eq!(size_of::<NonZeroU32>(), size_of::<Option<NonZeroU32>>());

///assert_eq!(align_of::<NonZeroU32>(), align_of::<Option<NonZeroU32>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU32",
functions[]
)]

pub struct NonZeroU32();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU64>` is the same size as `u64`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU64>>(), size_of::<u64>());

/// ```

/// # Layout

///`NonZeroU64` is guaranteed to have the same layout and bit validity as `u64`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU64>` is guaranteed to be compatible with `u64`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU64` and `Option<NonZeroU64>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU64;

///assert_eq!(size_of::<NonZeroU64>(), size_of::<Option<NonZeroU64>>());

///assert_eq!(align_of::<NonZeroU64>(), align_of::<Option<NonZeroU64>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU64",
functions[]
)]

pub struct NonZeroU64();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroU128>` is the same size as `u128`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroU128>>(), size_of::<u128>());

/// ```

/// # Layout

///`NonZeroU128` is guaranteed to have the same layout and bit validity as `u128`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroU128>` is guaranteed to be compatible with `u128`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroU128` and `Option<NonZeroU128>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroU128;

///assert_eq!(size_of::<NonZeroU128>(), size_of::<Option<NonZeroU128>>());

///assert_eq!(align_of::<NonZeroU128>(), align_of::<Option<NonZeroU128>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroU128",
functions[]
)]

pub struct NonZeroU128();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroUsize>` is the same size as `usize`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroUsize>>(), size_of::<usize>());

/// ```

/// # Layout

///`NonZeroUsize` is guaranteed to have the same layout and bit validity as `usize`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroUsize>` is guaranteed to be compatible with `usize`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroUsize` and `Option<NonZeroUsize>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroUsize;

///assert_eq!(size_of::<NonZeroUsize>(), size_of::<Option<NonZeroUsize>>());

///assert_eq!(align_of::<NonZeroUsize>(), align_of::<Option<NonZeroUsize>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroUsize",
functions[]
)]

pub struct NonZeroUsize();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI8>` is the same size as `i8`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI8>>(), size_of::<i8>());

/// ```

/// # Layout

///`NonZeroI8` is guaranteed to have the same layout and bit validity as `i8`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI8>` is guaranteed to be compatible with `i8`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI8` and `Option<NonZeroI8>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI8;

///assert_eq!(size_of::<NonZeroI8>(), size_of::<Option<NonZeroI8>>());

///assert_eq!(align_of::<NonZeroI8>(), align_of::<Option<NonZeroI8>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI8",
functions[]
)]

pub struct NonZeroI8();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI16>` is the same size as `i16`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI16>>(), size_of::<i16>());

/// ```

/// # Layout

///`NonZeroI16` is guaranteed to have the same layout and bit validity as `i16`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI16>` is guaranteed to be compatible with `i16`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI16` and `Option<NonZeroI16>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI16;

///assert_eq!(size_of::<NonZeroI16>(), size_of::<Option<NonZeroI16>>());

///assert_eq!(align_of::<NonZeroI16>(), align_of::<Option<NonZeroI16>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI16",
functions[]
)]

pub struct NonZeroI16();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI32>` is the same size as `i32`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI32>>(), size_of::<i32>());

/// ```

/// # Layout

///`NonZeroI32` is guaranteed to have the same layout and bit validity as `i32`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI32>` is guaranteed to be compatible with `i32`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI32` and `Option<NonZeroI32>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI32;

///assert_eq!(size_of::<NonZeroI32>(), size_of::<Option<NonZeroI32>>());

///assert_eq!(align_of::<NonZeroI32>(), align_of::<Option<NonZeroI32>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI32",
functions[]
)]

pub struct NonZeroI32();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI64>` is the same size as `i64`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI64>>(), size_of::<i64>());

/// ```

/// # Layout

///`NonZeroI64` is guaranteed to have the same layout and bit validity as `i64`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI64>` is guaranteed to be compatible with `i64`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI64` and `Option<NonZeroI64>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI64;

///assert_eq!(size_of::<NonZeroI64>(), size_of::<Option<NonZeroI64>>());

///assert_eq!(align_of::<NonZeroI64>(), align_of::<Option<NonZeroI64>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI64",
functions[]
)]

pub struct NonZeroI64();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroI128>` is the same size as `i128`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroI128>>(), size_of::<i128>());

/// ```

/// # Layout

///`NonZeroI128` is guaranteed to have the same layout and bit validity as `i128`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroI128>` is guaranteed to be compatible with `i128`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroI128` and `Option<NonZeroI128>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroI128;

///assert_eq!(size_of::<NonZeroI128>(), size_of::<Option<NonZeroI128>>());

///assert_eq!(align_of::<NonZeroI128>(), align_of::<Option<NonZeroI128>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroI128",
functions[]
)]

pub struct NonZeroI128();

/// An integer that is known not to equal zero.

/// This enables some memory layout optimization.

///For example, `Option<NonZeroIsize>` is the same size as `isize`:

/// ```rust

/// use std::mem::size_of;

///assert_eq!(size_of::<Option<core::num::NonZeroIsize>>(), size_of::<isize>());

/// ```

/// # Layout

///`NonZeroIsize` is guaranteed to have the same layout and bit validity as `isize`

/// with the exception that `0` is not a valid instance.

///`Option<NonZeroIsize>` is guaranteed to be compatible with `isize`,

/// including in FFI.

/// Thanks to the [null pointer optimization],

///`NonZeroIsize` and `Option<NonZeroIsize>`

/// are guaranteed to have the same size and alignment:

/// ```

/// # use std::mem::{size_of, align_of};

///use std::num::NonZeroIsize;

///assert_eq!(size_of::<NonZeroIsize>(), size_of::<Option<NonZeroIsize>>());

///assert_eq!(align_of::<NonZeroIsize>(), align_of::<Option<NonZeroIsize>>());

/// ```

/// [null pointer optimization]: crate::option#representation

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::num::NonZeroIsize",
functions[]
)]

pub struct NonZeroIsize();

/// An unbounded range (`..`).

/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.

/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.

/// # Examples

/// The `..` syntax is a `RangeFull`:

/// ```

/// assert_eq!(.., std::ops::RangeFull);

/// ```

/// It does not have an [`IntoIterator`] implementation, so you can't use it in

/// a `for` loop directly. This won't compile:

/// ```compile_fail,E0277

/// for i in .. {

///     // ...

/// }

/// ```

/// Used as a [slicing index], `RangeFull` produces the full array as a slice.

/// ```

/// let arr = [0, 1, 2, 3, 4];

/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]); // This is the `RangeFull`

/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);

/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);

/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);

/// assert_eq!(arr[1.. 3], [   1, 2      ]);

/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);

/// ```

/// [slicing index]: crate::slice::SliceIndex

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="std::ops::RangeFull",
functions[]
)]

pub struct RangeFull {}

/// A `Duration` type to represent a span of time, typically used for system

/// timeouts.

/// Each `Duration` is composed of a whole number of seconds and a fractional part

/// represented in nanoseconds. If the underlying system does not support

/// nanosecond-level precision, APIs binding a system timeout will typically round up

/// the number of nanoseconds.

/// [`Duration`]s implement many common traits, including [`Add`], [`Sub`], and other

/// [`ops`] traits. It implements [`Default`] by returning a zero-length `Duration`.

/// [`ops`]: crate::ops

/// # Examples

/// ```

/// use std::time::Duration;

/// let five_seconds = Duration::new(5, 0);

/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);

/// assert_eq!(five_seconds_and_five_nanos.as_secs(), 5);

/// assert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);

/// let ten_millis = Duration::from_millis(10);

/// ```

/// # Formatting `Duration` values

/// `Duration` intentionally does not have a `Display` impl, as there are a

/// variety of ways to format spans of time for human readability. `Duration`

/// provides a `Debug` impl that shows the full precision of the value.

/// The `Debug` output uses the non-ASCII "µs" suffix for microseconds. If your

/// program output may appear in contexts that cannot rely on full Unicode

/// compatibility, you may wish to format `Duration` objects yourself or use a

/// crate to do so.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug,),
remote="bevy::utils::Duration",
functions[]
)]

pub struct Duration {}

crate::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        Ok(())
    }
}

pub struct BevyReflectAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyReflectAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new(
            "BevyReflectAPI",
            |tw| {
                tw.document_global_instance::<Globals>()
                    .expect("Something went wrong documenting globals")
                    .process_type::<LuaOsString>()
                    .process_type::<LuaPathBuf>()
                    .process_type::<LuaInstant>()
                    .process_type::<LuaNonZeroU8>()
                    .process_type::<LuaNonZeroU16>()
                    .process_type::<LuaNonZeroU32>()
                    .process_type::<LuaNonZeroU64>()
                    .process_type::<LuaNonZeroU128>()
                    .process_type::<LuaNonZeroUsize>()
                    .process_type::<LuaNonZeroI8>()
                    .process_type::<LuaNonZeroI16>()
                    .process_type::<LuaNonZeroI32>()
                    .process_type::<LuaNonZeroI64>()
                    .process_type::<LuaNonZeroI128>()
                    .process_type::<LuaNonZeroIsize>()
                    .process_type::<LuaRangeFull>()
                    .process_type::<LuaDuration>()
            },
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<std::ffi::OsString>();

        app.register_foreign_lua_type::<std::path::PathBuf>();

        app.register_foreign_lua_type::<std::string::String>();

        app.register_foreign_lua_type::<bevy::utils::Instant>();

        app.register_foreign_lua_type::<std::num::NonZeroU8>();

        app.register_foreign_lua_type::<std::num::NonZeroU16>();

        app.register_foreign_lua_type::<std::num::NonZeroU32>();

        app.register_foreign_lua_type::<std::num::NonZeroU64>();

        app.register_foreign_lua_type::<std::num::NonZeroU128>();

        app.register_foreign_lua_type::<std::num::NonZeroUsize>();

        app.register_foreign_lua_type::<std::num::NonZeroI8>();

        app.register_foreign_lua_type::<std::num::NonZeroI16>();

        app.register_foreign_lua_type::<std::num::NonZeroI32>();

        app.register_foreign_lua_type::<std::num::NonZeroI64>();

        app.register_foreign_lua_type::<std::num::NonZeroI128>();

        app.register_foreign_lua_type::<std::num::NonZeroIsize>();

        app.register_foreign_lua_type::<std::ops::RangeFull>();

        app.register_foreign_lua_type::<bevy::utils::Duration>();
    }
}

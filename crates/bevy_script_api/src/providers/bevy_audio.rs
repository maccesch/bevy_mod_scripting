#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file

use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_transform::*;

extern crate self as bevy_script_api;

/// A volume level equivalent to a non-negative float.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::Volume",
functions[r#"
/// Create a new volume level.

    #[lua(kind = "Function", output(proxy))]
    fn new(volume: f32) -> bevy::audio::Volume;

"#,
			r#"
/// Get the value of the volume level.

    #[lua(kind = "Method")]
    fn get(&self) -> f32;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::Volume;

"#]
)]

pub struct LuaVolume();

/// The way Bevy manages the sound playback.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::PlaybackMode",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::PlaybackMode;

"#]
)]

pub struct LuaPlaybackMode {}

/// Initial settings to be used when audio starts playing.

/// If you would like to control the audio while it is playing, query for the

/// [`AudioSink`][crate::AudioSink] or [`SpatialAudioSink`][crate::SpatialAudioSink]

/// components. Changes to this component will *not* be applied to already-playing audio.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::prelude::PlaybackSettings",
functions[r#"
/// Helper to start in a paused state.

    #[lua(kind = "Method", output(proxy))]
    fn paused(self) -> bevy::audio::prelude::PlaybackSettings;

"#,
			r#"
/// Helper to set the volume from start of playback.

    #[lua(kind = "Method", output(proxy))]
    fn with_volume(
        self,
        #[proxy]
        volume: bevy::audio::Volume,
    ) -> bevy::audio::prelude::PlaybackSettings;

"#,
			r#"
/// Helper to set the speed from start of playback.

    #[lua(kind = "Method", output(proxy))]
    fn with_speed(self, speed: f32) -> bevy::audio::prelude::PlaybackSettings;

"#,
			r#"
/// Helper to enable or disable spatial audio.

    #[lua(kind = "Method", output(proxy))]
    fn with_spatial(self, spatial: bool) -> bevy::audio::prelude::PlaybackSettings;

"#,
			r#"
/// Helper to use a custom spatial scale.

    #[lua(kind = "Method", output(proxy))]
    fn with_spatial_scale(
        self,
        #[proxy]
        spatial_scale: bevy::audio::SpatialScale,
    ) -> bevy::audio::prelude::PlaybackSettings;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::prelude::PlaybackSettings;

"#]
)]

pub struct LuaPlaybackSettings {}

/// Settings for the listener for spatial audio sources.

/// This must be accompanied by `Transform` and `GlobalTransform`.

/// Only one entity with a `SpatialListener` should be present at any given time.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::prelude::SpatialListener",
functions[r#"
/// Creates a new `SpatialListener` component.
/// `gap` is the distance between the left and right "ears" of the listener. Ears are
/// positioned on the x axis.

    #[lua(kind = "Function", output(proxy))]
    fn new(gap: f32) -> bevy::audio::prelude::SpatialListener;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::prelude::SpatialListener;

"#]
)]

pub struct LuaSpatialListener {}

/// Use this [`Resource`] to control the global volume of all audio.

/// Note: changing this value will not affect already playing audio.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::prelude::GlobalVolume",
functions[r#"
/// Create a new [`GlobalVolume`] with the given volume.

    #[lua(kind = "Function", output(proxy))]
    fn new(volume: f32) -> bevy::audio::prelude::GlobalVolume;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::prelude::GlobalVolume;

"#]
)]

pub struct LuaGlobalVolume {}

/// A scale factor applied to the positions of audio sources and listeners for

/// spatial audio.

/// Default is `Vec3::ONE`.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::SpatialScale",
functions[r#"
/// Create a new `SpatialScale` with the same value for all 3 dimensions.

    #[lua(kind = "Function", output(proxy))]
    fn new(scale: f32) -> bevy::audio::SpatialScale;

"#,
			r#"
/// Create a new `SpatialScale` with the same value for `x` and `y`, and `0.0`
/// for `z`.

    #[lua(kind = "Function", output(proxy))]
    fn new_2d(scale: f32) -> bevy::audio::SpatialScale;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::SpatialScale;

"#]
)]

pub struct LuaSpatialScale();

/// The default scale factor applied to the positions of audio sources and listeners for

/// spatial audio. Can be overridden for individual sounds in [`PlaybackSettings`].

/// You may need to adjust this scale to fit your world's units.

/// Default is `Vec3::ONE`.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::audio::DefaultSpatialScale",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::audio::DefaultSpatialScale;

"#]
)]

pub struct LuaDefaultSpatialScale();

crate::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances.add_instance(
            "LuaVolume",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaVolume>::new,
        )?;

        instances.add_instance(
            "LuaSpatialListener",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaSpatialListener>::new,
        )?;

        instances.add_instance(
            "LuaGlobalVolume",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaGlobalVolume>::new,
        )?;

        instances.add_instance(
            "LuaSpatialScale",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaSpatialScale>::new,
        )?;

        Ok(())
    }
}

pub struct BevyAudioAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyAudioAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new(
            "BevyAudioAPI",
            |tw| {
                tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaVolume>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaVolume>>()
                
            
                .process_type::<LuaPlaybackMode>()
                
            
                .process_type::<LuaPlaybackSettings>()
                
            
                .process_type::<LuaSpatialListener>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaSpatialListener>>()
                
            
                .process_type::<LuaGlobalVolume>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaGlobalVolume>>()
                
            
                .process_type::<LuaSpatialScale>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaSpatialScale>>()
                
            
                .process_type::<LuaDefaultSpatialScale>()
            },
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::audio::Volume>();

        app.register_foreign_lua_type::<bevy::audio::PlaybackMode>();

        app.register_foreign_lua_type::<bevy::audio::prelude::PlaybackSettings>();

        app.register_foreign_lua_type::<bevy::audio::prelude::SpatialListener>();

        app.register_foreign_lua_type::<bevy::audio::prelude::GlobalVolume>();

        app.register_foreign_lua_type::<bevy::audio::SpatialScale>();

        app.register_foreign_lua_type::<bevy::audio::DefaultSpatialScale>();
    }
}

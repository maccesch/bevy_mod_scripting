#![allow(clippy::all, unused_imports, deprecated, dead_code)]
// @generated by cargo bevy-api-gen generate, modify the templates not this file

use super::bevy_ecs::*;

use super::bevy_reflect::*;

use super::bevy_asset::*;

use super::bevy_core::*;

use super::bevy_hierarchy::*;

use super::bevy_input::*;

use super::bevy_window::*;

use super::bevy_render::*;

use super::bevy_time::*;

use super::bevy_transform::*;

use super::bevy_core_pipeline::*;

use super::bevy_sprite::*;

use super::bevy_text::*;

extern crate self as bevy_script_api;

/// A node with a `ContentSize` component is a node where its size

/// is based on its content.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::measurement::ContentSize",
functions[r#"
/// Creates a `ContentSize` with a `Measure` that always returns given `size` argument, regardless of the UI layout's constraints.

    #[lua(kind = "Function", output(proxy))]
    fn fixed_size(#[proxy] size: bevy::math::Vec2) -> bevy::ui::measurement::ContentSize;

"#]
)]

pub struct LuaContentSize {}

/// Marker struct for buttons

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::widget::Button",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::widget::Button;

"#]
)]

pub struct LuaButton {}

/// The size of the image's texture

/// This component is updated automatically by [`update_image_content_size_system`]

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::widget::UiImageSize",
functions[r#"
/// The size of the image's texture

    #[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy::math::Vec2;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::widget::UiImageSize;

"#]
)]

pub struct LuaUiImageSize {}

/// Marker struct for labels

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::widget::Label",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::widget::Label;

"#]
)]

pub struct LuaLabel {}

/// Text system flags

/// Used internally by [`measure_text_system`] and [`text_system`] to schedule text for processing.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::widget::TextFlags",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::widget::TextFlags;

"#]
)]

pub struct LuaTextFlags {}

/// Describes what type of input interaction has occurred for a UI node.

/// This is commonly queried with a `Changed<Interaction>` filter.

/// Updated in [`ui_focus_system`].

/// If a UI node has both [`Interaction`] and [`ViewVisibility`] components,

/// [`Interaction`] will always be [`Interaction::None`]

/// when [`ViewVisibility::get()`] is false.

/// This ensures that hidden UI nodes are not interactable,

/// and do not end up stuck in an active state if hidden at the wrong time.

/// Note that you can also control the visibility of a node using the [`Display`](crate::ui_node::Display) property,

/// which fully collapses it during layout calculations.

/// # See also

/// - [`ButtonBundle`](crate::node_bundles::ButtonBundle) which includes this component

/// - [`RelativeCursorPosition`] to obtain the position of the cursor relative to current node

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Interaction",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Interaction;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &focus::Interaction) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaInteraction {}

/// A component storing the position of the mouse relative to the node, (0., 0.) being the top-left corner and (1., 1.) being the bottom-right

/// If the mouse is not over the node, the value will go beyond the range of (0., 0.) to (1., 1.)

/// It can be used alongside [`Interaction`] to get the position of the press.

/// The component is updated when it is in the same entity with [`Node`].

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::RelativeCursorPosition",
functions[r#"
/// A helper function to check if the mouse is over the node

    #[lua(kind = "Method")]
    fn mouse_over(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::RelativeCursorPosition;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &focus::RelativeCursorPosition) -> bool;

"#]
)]

pub struct LuaRelativeCursorPosition {}

/// Describes whether the node should block interactions with lower nodes

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::FocusPolicy",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::FocusPolicy;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &focus::FocusPolicy) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaFocusPolicy {}

/// Represents the possible value types for layout properties.

/// This enum allows specifying values for various [`Style`](crate::Style) properties in different units,

/// such as logical pixels, percentages, or automatically determined values.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Val",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Val;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Neg",
        kind = "Function",
        output(proxy),
        composite = "neg",
        metamethod = "Unm",
    )]
    fn neg(self) -> bevy::ui::prelude::Val;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Div",
        kind = "Function",
        output(proxy),
        composite = "div",
        metamethod = "Div",
    )]
    fn div(self, rhs: f32) -> bevy::ui::prelude::Val;

"#,
			r#"

    #[lua(
        as_trait = "std::ops::Mul",
        kind = "Function",
        output(proxy),
        composite = "mul",
        metamethod = "Mul",
    )]
    fn mul(self, rhs: f32) -> bevy::ui::prelude::Val;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &geometry::Val) -> bool;

"#]
)]

pub struct LuaVal {}

/// A type which is commonly used to define margins, paddings and borders.

/// # Examples

/// ## Margin

/// A margin is used to create space around UI elements, outside of any defined borders.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let margin = UiRect::all(Val::Auto); // Centers the UI element

/// ```

/// ## Padding

/// A padding is used to create space around UI elements, inside of any defined borders.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let padding = UiRect {

///     left: Val::Px(10.0),

///     right: Val::Px(20.0),

///     top: Val::Px(30.0),

///     bottom: Val::Px(40.0),

/// };

/// ```

/// ## Borders

/// A border is used to define the width of the border of a UI element.

/// ```

/// # use bevy_ui::{UiRect, Val};

/// #

/// let border = UiRect {

///     left: Val::Px(10.0),

///     right: Val::Px(20.0),

///     top: Val::Px(30.0),

///     bottom: Val::Px(40.0),

/// };

/// ```

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::UiRect",
functions[r#"
/// Creates a new [`UiRect`] from the values specified.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::new(
///     Val::Px(10.0),
///     Val::Px(20.0),
///     Val::Px(30.0),
///     Val::Px(40.0),
/// );
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(20.0));
/// assert_eq!(ui_rect.top, Val::Px(30.0));
/// assert_eq!(ui_rect.bottom, Val::Px(40.0));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        left: bevy::ui::prelude::Val,
        #[proxy]
        right: bevy::ui::prelude::Val,
        #[proxy]
        top: bevy::ui::prelude::Val,
        #[proxy]
        bottom: bevy::ui::prelude::Val,
    ) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where all sides have the same value.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::all(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn all(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] from the values specified in logical pixels.
/// This is a shortcut for [`UiRect::new()`], applying [`Val::Px`] to all arguments.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::px(10., 20., 30., 40.);
/// assert_eq!(ui_rect.left, Val::Px(10.));
/// assert_eq!(ui_rect.right, Val::Px(20.));
/// assert_eq!(ui_rect.top, Val::Px(30.));
/// assert_eq!(ui_rect.bottom, Val::Px(40.));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn px(left: f32, right: f32, top: f32, bottom: f32) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] from the values specified in percentages.
/// This is a shortcut for [`UiRect::new()`], applying [`Val::Percent`] to all arguments.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::percent(5., 10., 2., 1.);
/// assert_eq!(ui_rect.left, Val::Percent(5.));
/// assert_eq!(ui_rect.right, Val::Percent(10.));
/// assert_eq!(ui_rect.top, Val::Percent(2.));
/// assert_eq!(ui_rect.bottom, Val::Percent(1.));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn percent(
        left: f32,
        right: f32,
        top: f32,
        bottom: f32,
    ) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `left` and `right` take the given value,
/// and `top` and `bottom` set to zero `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::horizontal(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::ZERO);
/// assert_eq!(ui_rect.bottom, Val::ZERO);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn horizontal(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `top` and `bottom` take the given value,
/// and `left` and `right` are set to `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::vertical(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::ZERO);
/// assert_eq!(ui_rect.right, Val::ZERO);
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn vertical(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where both `left` and `right` take the value of `horizontal`, and both `top` and `bottom` take the value of `vertical`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::axes(Val::Px(10.0), Val::Percent(15.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::Percent(15.0));
/// assert_eq!(ui_rect.bottom, Val::Percent(15.0));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn axes(
        #[proxy]
        horizontal: bevy::ui::prelude::Val,
        #[proxy]
        vertical: bevy::ui::prelude::Val,
    ) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `left` takes the given value, and
/// the other fields are set to `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::left(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::Px(10.0));
/// assert_eq!(ui_rect.right, Val::ZERO);
/// assert_eq!(ui_rect.top, Val::ZERO);
/// assert_eq!(ui_rect.bottom, Val::ZERO);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn left(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `right` takes the given value,
/// and the other fields are set to `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::right(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::ZERO);
/// assert_eq!(ui_rect.right, Val::Px(10.0));
/// assert_eq!(ui_rect.top, Val::ZERO);
/// assert_eq!(ui_rect.bottom, Val::ZERO);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn right(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `top` takes the given value,
/// and the other fields are set to `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::top(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::ZERO);
/// assert_eq!(ui_rect.right, Val::ZERO);
/// assert_eq!(ui_rect.top, Val::Px(10.0));
/// assert_eq!(ui_rect.bottom, Val::ZERO);
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn top(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"
/// Creates a new [`UiRect`] where `bottom` takes the given value,
/// and the other fields are set to `Val::ZERO`.
/// # Example
/// ```
/// # use bevy_ui::{UiRect, Val};
/// #
/// let ui_rect = UiRect::bottom(Val::Px(10.0));
/// assert_eq!(ui_rect.left, Val::ZERO);
/// assert_eq!(ui_rect.right, Val::ZERO);
/// assert_eq!(ui_rect.top, Val::ZERO);
/// assert_eq!(ui_rect.bottom, Val::Px(10.0));
/// ```

    #[lua(kind = "Function", output(proxy))]
    fn bottom(#[proxy] value: bevy::ui::prelude::Val) -> bevy::ui::prelude::UiRect;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::UiRect;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &geometry::UiRect) -> bool;

"#]
)]

pub struct LuaUiRect {}

/// Base component for a UI node, which also provides the computed size of the node.

/// # See also

/// - [`node_bundles`](crate::node_bundles) for the list of built-in bundles that set up UI node

/// - [`RelativeCursorPosition`](crate::RelativeCursorPosition)

///   to obtain the cursor position relative to this node

/// - [`Interaction`](crate::Interaction) to obtain the interaction state of this node

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Node",
functions[r#"
/// The calculated node size as width and height in logical pixels.
/// Automatically calculated by [`super::layout::ui_layout_system`].

    #[lua(kind = "Method", output(proxy))]
    fn size(&self) -> bevy::math::Vec2;

"#,
			r#"
/// The order of the node in the UI layout.
/// Nodes with a higher stack index are drawn on top of and recieve interactions before nodes with lower stack indices.

    #[lua(kind = "Method")]
    fn stack_index(&self) -> u32;

"#,
			r#"
/// The calculated node size as width and height in logical pixels before rounding.
/// Automatically calculated by [`super::layout::ui_layout_system`].

    #[lua(kind = "Method", output(proxy))]
    fn unrounded_size(&self) -> bevy::math::Vec2;

"#,
			r#"
/// Returns the size of the node in physical pixels based on the given scale factor and `UiScale`.

    #[lua(kind = "Method", output(proxy))]
    fn physical_size(&self, scale_factor: f32, ui_scale: f32) -> bevy::math::Vec2;

"#,
			r#"
/// Returns the thickness of the UI node's outline.
/// If this value is negative or `0.` then no outline will be rendered.

    #[lua(kind = "Method")]
    fn outline_width(&self) -> f32;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Node;

"#]
)]

pub struct LuaNode {}

/// Describes the style of a UI container node

/// Nodes can be laid out using either Flexbox or CSS Grid Layout.

/// See below for general learning resources and for documentation on the individual style properties.

/// ### Flexbox

/// - [MDN: Basic Concepts of Flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

/// - [A Complete Guide To Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) by CSS Tricks. This is detailed guide with illustrations and comprehensive written explanation of the different Flexbox properties and how they work.

/// - [Flexbox Froggy](https://flexboxfroggy.com/). An interactive tutorial/game that teaches the essential parts of Flexbox in a fun engaging way.

/// ### CSS Grid

/// - [MDN: Basic Concepts of Grid Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout)

/// - [A Complete Guide To CSS Grid](https://css-tricks.com/snippets/css/complete-guide-grid/) by CSS Tricks. This is detailed guide with illustrations and comprehensive written explanation of the different CSS Grid properties and how they work.

/// - [CSS Grid Garden](https://cssgridgarden.com/). An interactive tutorial/game that teaches the essential parts of CSS Grid in a fun engaging way.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Style",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Style;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::Style) -> bool;

"#]
)]

pub struct LuaStyle {}

/// Used to control how each individual item is aligned by default within the space they're given.

/// - For Flexbox containers, sets default cross axis alignment of the child items.

/// - For CSS Grid containers, controls block (vertical) axis alignment of children of this grid container within their grid areas.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-items>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::AlignItems",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::AlignItems;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::AlignItems) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaAlignItems {}

/// Used to control how each individual item is aligned by default within the space they're given.

/// - For Flexbox containers, this property has no effect. See `justify_content` for main axis alignment of flex items.

/// - For CSS Grid containers, sets default inline (horizontal) axis alignment of child items within their grid areas.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::JustifyItems",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::JustifyItems;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::JustifyItems) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaJustifyItems {}

/// Used to control how the specified item is aligned within the space it's given.

/// - For Flexbox items, controls cross axis alignment of the item.

/// - For CSS Grid items, controls block (vertical) axis alignment of a grid item within its grid area.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-self>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::AlignSelf",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::AlignSelf;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::AlignSelf) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaAlignSelf {}

/// Used to control how the specified item is aligned within the space it's given.

/// - For Flexbox items, this property has no effect. See `justify_content` for main axis alignment of flex items.

/// - For CSS Grid items, controls inline (horizontal) axis alignment of a grid item within its grid area.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::JustifySelf",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::JustifySelf;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::JustifySelf) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaJustifySelf {}

/// Used to control how items are distributed.

/// - For Flexbox containers, controls alignment of lines if `flex_wrap` is set to [`FlexWrap::Wrap`] and there are multiple lines of items.

/// - For CSS Grid containers, controls alignment of grid rows.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-content>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::AlignContent",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::AlignContent;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::AlignContent) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaAlignContent {}

/// Used to control how items are distributed.

/// - For Flexbox containers, controls alignment of items in the main axis.

/// - For CSS Grid containers, controls alignment of grid columns.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::JustifyContent",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::JustifyContent;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::JustifyContent) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaJustifyContent {}

/// Defines the text direction.

/// For example, English is written LTR (left-to-right) while Arabic is written RTL (right-to-left).

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Direction",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Direction;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::Direction) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaDirection {}

/// Defines the layout model used by this node.

/// Part of the [`Style`] component.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Display",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Display;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::Display) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaDisplay {}

/// Defines how flexbox items are ordered within a flexbox

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::FlexDirection",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::FlexDirection;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::FlexDirection) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaFlexDirection {}

/// Whether to show or hide overflowing items

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Overflow",
functions[r#"
/// Show overflowing items on both axes

    #[lua(kind = "Function", output(proxy))]
    fn visible() -> bevy::ui::prelude::Overflow;

"#,
			r#"
/// Clip overflowing items on both axes

    #[lua(kind = "Function", output(proxy))]
    fn clip() -> bevy::ui::prelude::Overflow;

"#,
			r#"
/// Clip overflowing items on the x axis

    #[lua(kind = "Function", output(proxy))]
    fn clip_x() -> bevy::ui::prelude::Overflow;

"#,
			r#"
/// Clip overflowing items on the y axis

    #[lua(kind = "Function", output(proxy))]
    fn clip_y() -> bevy::ui::prelude::Overflow;

"#,
			r#"
/// Overflow is visible on both axes

    #[lua(kind = "Method")]
    fn is_visible(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Overflow;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::Overflow) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaOverflow {}

/// Whether to show or hide overflowing items

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::OverflowAxis",
functions[r#"
/// Overflow is visible on this axis

    #[lua(kind = "Method")]
    fn is_visible(&self) -> bool;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::OverflowAxis;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::OverflowAxis) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaOverflowAxis {}

/// The strategy used to position this node

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::PositionType",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::PositionType;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::PositionType) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaPositionType {}

/// Defines if flexbox items appear on a single line or on multiple lines

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::FlexWrap",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::FlexWrap;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::FlexWrap) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaFlexWrap {}

/// Controls whether grid items are placed row-wise or column-wise as well as whether the sparse or dense packing algorithm is used.

/// The "dense" packing algorithm attempts to fill in holes earlier in the grid, if smaller items come up later.

/// This may cause items to appear out-of-order when doing so would fill in holes left by larger items.

/// Defaults to [`GridAutoFlow::Row`].

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::GridAutoFlow",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::GridAutoFlow;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::GridAutoFlow) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaGridAutoFlow {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::MinTrackSizingFunction",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::MinTrackSizingFunction;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::MinTrackSizingFunction) -> bool;

"#]
)]

pub struct LuaMinTrackSizingFunction {}

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::MaxTrackSizingFunction",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::MaxTrackSizingFunction;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::MaxTrackSizingFunction) -> bool;

"#]
)]

pub struct LuaMaxTrackSizingFunction {}

/// A [`GridTrack`] is a Row or Column of a CSS Grid. This struct specifies what size the track should be.

/// See below for the different "track sizing functions" you can specify.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::GridTrack",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::GridTrack;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::GridTrack) -> bool;

"#]
)]

pub struct LuaGridTrack {}

/// How many times to repeat a repeated grid track

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/repeat>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::GridTrackRepetition",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::GridTrackRepetition;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::GridTrackRepetition) -> bool;

"#]
)]

pub struct LuaGridTrackRepetition {}

/// Represents a *possibly* repeated [`GridTrack`].

/// The repetition parameter can either be:

///   - The integer `1`, in which case the track is non-repeated.

///   - a `u16` count to repeat the track N times.

///   - A `GridTrackRepetition::AutoFit` or `GridTrackRepetition::AutoFill`.

/// Note: that in the common case you want a non-repeating track (repetition count 1), you may use the constructor methods on [`GridTrack`]

/// to create a `RepeatedGridTrack`. i.e. `GridTrack::px(10.0)` is equivalent to `RepeatedGridTrack::px(1, 10.0)`.

/// You may only use one auto-repetition per track list. And if your track list contains an auto repetition

/// then all tracks (in and outside of the repetition) must be fixed size (px or percent). Integer repetitions are just shorthand for writing out

/// N tracks longhand and are not subject to the same limitations.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::RepeatedGridTrack",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::RepeatedGridTrack;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::RepeatedGridTrack) -> bool;

"#]
)]

pub struct LuaRepeatedGridTrack {}

/// Represents the position of a grid item in a single axis.

/// There are 3 fields which may be set:

///   - `start`: which grid line the item should start at

///   - `end`: which grid line the item should end at

///   - `span`: how many tracks the item should span

/// The default `span` is 1. If neither `start` or `end` is set then the item will be placed automatically.

/// Generally, at most two fields should be set. If all three fields are specified then `span` will be ignored. If `end` specifies an earlier

/// grid line than `start` then `end` will be ignored and the item will have a span of 1.

/// <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid>

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::GridPlacement",
functions[r#"
/// Place the grid item automatically (letting the `span` default to `1`).

    #[lua(kind = "Function", output(proxy))]
    fn auto() -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item automatically, specifying how many tracks it should `span`.
/// # Panics
/// Panics if `span` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn span(span: u16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item specifying the `start` grid line (letting the `span` default to `1`).
/// # Panics
/// Panics if `start` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn start(start: i16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item specifying the `end` grid line (letting the `span` default to `1`).
/// # Panics
/// Panics if `end` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn end(end: i16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item specifying the `start` grid line and how many tracks it should `span`.
/// # Panics
/// Panics if `start` or `span` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn start_span(start: i16, span: u16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item specifying `start` and `end` grid lines (`span` will be inferred)
/// # Panics
/// Panics if `start` or `end` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn start_end(start: i16, end: i16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Place the grid item specifying the `end` grid line and how many tracks it should `span`.
/// # Panics
/// Panics if `end` or `span` is `0`.

    #[lua(kind = "Function", output(proxy))]
    fn end_span(end: i16, span: u16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Mutate the item, setting the `start` grid line
/// # Panics
/// Panics if `start` is `0`.

    #[lua(kind = "Method", output(proxy))]
    fn set_start(self, start: i16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Mutate the item, setting the `end` grid line
/// # Panics
/// Panics if `end` is `0`.

    #[lua(kind = "Method", output(proxy))]
    fn set_end(self, end: i16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Mutate the item, setting the number of tracks the item should `span`
/// # Panics
/// Panics if `span` is `0`.

    #[lua(kind = "Method", output(proxy))]
    fn set_span(self, span: u16) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"
/// Returns the grid line at which the item should start, or `None` if not set.

    #[lua(kind = "Method")]
    fn get_start(self) -> std::option::Option<i16>;

"#,
			r#"
/// Returns the grid line at which the item should end, or `None` if not set.

    #[lua(kind = "Method")]
    fn get_end(self) -> std::option::Option<i16>;

"#,
			r#"
/// Returns span for this grid item, or `None` if not set.

    #[lua(kind = "Method")]
    fn get_span(self) -> std::option::Option<u16>;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::GridPlacement;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::GridPlacement) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaGridPlacement {}

/// The background color of the node

/// This serves as the "fill" color.

/// When combined with [`UiImage`], tints the provided texture.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::BackgroundColor",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::BackgroundColor;

"#]
)]

pub struct LuaBackgroundColor();

/// The border color of the UI node.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::BorderColor",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::BorderColor;

"#]
)]

pub struct LuaBorderColor();

/// The [`Outline`] component adds an outline outside the edge of a UI node.

/// Outlines do not take up space in the layout.

/// To add an [`Outline`] to a ui node you can spawn a `(NodeBundle, Outline)` tuple bundle:

/// ```

/// # use bevy_ecs::prelude::*;

/// # use bevy_ui::prelude::*;

/// # use bevy_render::prelude::Color;

/// fn setup_ui(mut commands: Commands) {

///     commands.spawn((

///         NodeBundle {

///             style: Style {

///                 width: Val::Px(100.),

///                 height: Val::Px(100.),

///                 ..Default::default()

///             },

///             background_color: Color::BLUE.into(),

///             ..Default::default()

///         },

///         Outline::new(Val::Px(10.), Val::ZERO, Color::RED)

///     ));

/// }

/// ```

/// [`Outline`] components can also be added later to existing UI nodes:

/// ```

/// # use bevy_ecs::prelude::*;

/// # use bevy_ui::prelude::*;

/// # use bevy_render::prelude::Color;

/// fn outline_hovered_button_system(

///     mut commands: Commands,

///     mut node_query: Query<(Entity, &Interaction, Option<&mut Outline>), Changed<Interaction>>,

/// ) {

///     for (entity, interaction, mut maybe_outline) in node_query.iter_mut() {

///         let outline_color =

///             if matches!(*interaction, Interaction::Hovered) {

///                 Color::WHITE

///             } else {

///                 Color::NONE

///             };

///         if let Some(mut outline) = maybe_outline {

///             outline.color = outline_color;

///         } else {

///             commands.entity(entity).insert(Outline::new(Val::Px(10.), Val::ZERO, outline_color));

///         }

///     }

/// }

/// ```

/// Inserting and removing an [`Outline`] component repeatedly will result in table moves, so it is generally preferable to

/// set `Outline::color` to `Color::NONE` to hide an outline.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::Outline",
functions[r#"
/// Create a new outline

    #[lua(kind = "Function", output(proxy))]
    fn new(
        #[proxy]
        width: bevy::ui::prelude::Val,
        #[proxy]
        offset: bevy::ui::prelude::Val,
        #[proxy]
        color: bevy::render::color::Color,
    ) -> bevy::ui::prelude::Outline;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::Outline;

"#]
)]

pub struct LuaOutline {}

/// The 2D texture displayed for this UI node

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::UiImage",
functions[r#"
/// Flip the image along its x-axis

    #[lua(kind = "Method", output(proxy))]
    fn with_flip_x(self) -> bevy::ui::prelude::UiImage;

"#,
			r#"
/// Flip the image along its y-axis

    #[lua(kind = "Method", output(proxy))]
    fn with_flip_y(self) -> bevy::ui::prelude::UiImage;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::UiImage;

"#]
)]

pub struct LuaUiImage {}

/// The calculated clip of the node

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::CalculatedClip",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::CalculatedClip;

"#]
)]

pub struct LuaCalculatedClip {}

/// Indicates that this [`Node`] entity's front-to-back ordering is not controlled solely

/// by its location in the UI hierarchy. A node with a higher z-index will appear on top

/// of other nodes with a lower z-index.

/// UI nodes that have the same z-index will appear according to the order in which they

/// appear in the UI hierarchy. In such a case, the last node to be added to its parent

/// will appear in front of its siblings.

/// Internally, nodes with a global z-index share the stacking context of root UI nodes

/// (nodes that have no parent). Because of this, there is no difference between using

/// `ZIndex::Local(n)` and `ZIndex::Global(n)` for root nodes.

/// Nodes without this component will be treated as if they had a value of `ZIndex::Local(0)`.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::ZIndex",
functions[r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::ZIndex;

"#]
)]

pub struct LuaZIndex {}

/// Indicates that this root [`Node`] entity should be rendered to a specific camera.

/// UI then will be layed out respecting the camera's viewport and scale factor, and

/// rendered to this camera's [`bevy_render::camera::RenderTarget`].

/// Setting this component on a non-root node will have no effect. It will be overriden

/// by the root node's component.

/// Optional if there is only one camera in the world. Required otherwise.

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::TargetCamera",
functions[r#"

    #[lua(kind = "Method", output(proxy))]
    fn entity(&self) -> bevy::ecs::entity::Entity;

"#,
			r#"

    #[lua(as_trait = "std::clone::Clone", kind = "Method", output(proxy))]
    fn clone(&self) -> bevy::ui::prelude::TargetCamera;

"#,
			r#"

    #[lua(as_trait = "std::cmp::PartialEq", kind = "Method")]
    fn eq(&self, #[proxy] other: &ui_node::TargetCamera) -> bool;

"#,
			r#"

    #[lua(
        as_trait = "std::cmp::Eq",
        kind = "Function",
        composite = "assert_receiver_is_total_eq",
    )]
    fn assert_receiver_is_total_eq(&self) -> ();

"#]
)]

pub struct LuaTargetCamera();

/// The current scale of the UI.

/// A multiplier to fixed-sized ui values.

/// **Note:** This will only affect fixed ui values like [`Val::Px`]

#[derive(bevy_mod_scripting_lua_derive::LuaProxy)]
#[proxy(
derive(clone,debug),
remote="bevy::ui::prelude::UiScale",
functions[]
)]

pub struct LuaUiScale();

crate::impl_tealr_generic!(pub(crate) struct T);

#[derive(Default)]
pub(crate) struct Globals;

impl bevy_mod_scripting_lua::tealr::mlu::ExportInstances for Globals {
    fn add_instances<'lua, T: bevy_mod_scripting_lua::tealr::mlu::InstanceCollector<'lua>>(
        self,
        instances: &mut T,
    ) -> bevy_mod_scripting_lua::tealr::mlu::mlua::Result<()> {
        instances.add_instance(
            "LuaContentSize",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaContentSize>::new,
        )?;

        instances.add_instance(
            "LuaUiRect",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaUiRect>::new,
        )?;

        instances.add_instance(
            "LuaOverflow",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaOverflow>::new,
        )?;

        instances.add_instance(
            "LuaGridPlacement",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaGridPlacement>::new,
        )?;

        instances.add_instance(
            "LuaOutline",
            bevy_mod_scripting_lua::tealr::mlu::UserDataProxy::<LuaOutline>::new,
        )?;

        Ok(())
    }
}

pub struct BevyUiAPIProvider;

impl bevy_mod_scripting_core::hosts::APIProvider for BevyUiAPIProvider {
    type APITarget = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type ScriptContext = std::sync::Mutex<bevy_mod_scripting_lua::tealr::mlu::mlua::Lua>;
    type DocTarget = bevy_mod_scripting_lua::docs::LuaDocFragment;

    fn attach_api(
        &mut self,
        ctx: &mut Self::APITarget,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        let ctx = ctx
            .get_mut()
            .expect("Unable to acquire lock on Lua context");
        bevy_mod_scripting_lua::tealr::mlu::set_global_env(Globals, ctx)
            .map_err(|e| bevy_mod_scripting_core::error::ScriptError::Other(e.to_string()))
    }

    fn get_doc_fragment(&self) -> Option<Self::DocTarget> {
        Some(bevy_mod_scripting_lua::docs::LuaDocFragment::new(
            "BevyUiAPI",
            |tw| {
                tw
                .document_global_instance::<Globals>().expect("Something went wrong documenting globals")
            
                .process_type::<LuaContentSize>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaContentSize>>()
                
            
                .process_type::<LuaButton>()
                
            
                .process_type::<LuaUiImageSize>()
                
            
                .process_type::<LuaLabel>()
                
            
                .process_type::<LuaTextFlags>()
                
            
                .process_type::<LuaInteraction>()
                
            
                .process_type::<LuaRelativeCursorPosition>()
                
            
                .process_type::<LuaFocusPolicy>()
                
            
                .process_type::<LuaVal>()
                
            
                .process_type::<LuaUiRect>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaUiRect>>()
                
            
                .process_type::<LuaNode>()
                
            
                .process_type::<LuaStyle>()
                
            
                .process_type::<LuaAlignItems>()
                
            
                .process_type::<LuaJustifyItems>()
                
            
                .process_type::<LuaAlignSelf>()
                
            
                .process_type::<LuaJustifySelf>()
                
            
                .process_type::<LuaAlignContent>()
                
            
                .process_type::<LuaJustifyContent>()
                
            
                .process_type::<LuaDirection>()
                
            
                .process_type::<LuaDisplay>()
                
            
                .process_type::<LuaFlexDirection>()
                
            
                .process_type::<LuaOverflow>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaOverflow>>()
                
            
                .process_type::<LuaOverflowAxis>()
                
            
                .process_type::<LuaPositionType>()
                
            
                .process_type::<LuaFlexWrap>()
                
            
                .process_type::<LuaGridAutoFlow>()
                
            
                .process_type::<LuaMinTrackSizingFunction>()
                
            
                .process_type::<LuaMaxTrackSizingFunction>()
                
            
                .process_type::<LuaGridTrack>()
                
            
                .process_type::<LuaGridTrackRepetition>()
                
            
                .process_type::<LuaRepeatedGridTrack>()
                
            
                .process_type::<LuaGridPlacement>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaGridPlacement>>()
                
            
                .process_type::<LuaBackgroundColor>()
                
            
                .process_type::<LuaBorderColor>()
                
            
                .process_type::<LuaOutline>()
                
                .process_type::<bevy_mod_scripting_lua::tealr::mlu::UserDataProxy<LuaOutline>>()
                
            
                .process_type::<LuaUiImage>()
                
            
                .process_type::<LuaCalculatedClip>()
                
            
                .process_type::<LuaZIndex>()
                
            
                .process_type::<LuaTargetCamera>()
                
            
                .process_type::<LuaUiScale>()
            },
        ))
    }

    fn setup_script(
        &mut self,
        script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn setup_script_runtime(
        &mut self,
        world_ptr: bevy_mod_scripting_core::world::WorldPointer,
        _script_data: &bevy_mod_scripting_core::hosts::ScriptData,
        ctx: &mut Self::ScriptContext,
    ) -> Result<(), bevy_mod_scripting_core::error::ScriptError> {
        Ok(())
    }

    fn register_with_app(&self, app: &mut bevy::app::App) {
        app.register_foreign_lua_type::<bevy::ui::measurement::ContentSize>();

        app.register_foreign_lua_type::<bevy::ui::widget::Button>();

        app.register_foreign_lua_type::<bevy::ui::widget::UiImageSize>();

        app.register_foreign_lua_type::<bevy::ui::widget::Label>();

        app.register_foreign_lua_type::<bevy::ui::widget::TextFlags>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Interaction>();

        app.register_foreign_lua_type::<bevy::ui::RelativeCursorPosition>();

        app.register_foreign_lua_type::<bevy::ui::FocusPolicy>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Val>();

        app.register_foreign_lua_type::<bevy::ui::prelude::UiRect>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Node>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Style>();

        app.register_foreign_lua_type::<bevy::ui::prelude::AlignItems>();

        app.register_foreign_lua_type::<bevy::ui::prelude::JustifyItems>();

        app.register_foreign_lua_type::<bevy::ui::prelude::AlignSelf>();

        app.register_foreign_lua_type::<bevy::ui::prelude::JustifySelf>();

        app.register_foreign_lua_type::<bevy::ui::prelude::AlignContent>();

        app.register_foreign_lua_type::<bevy::ui::prelude::JustifyContent>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Direction>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Display>();

        app.register_foreign_lua_type::<bevy::ui::prelude::FlexDirection>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Overflow>();

        app.register_foreign_lua_type::<bevy::ui::prelude::OverflowAxis>();

        app.register_foreign_lua_type::<bevy::ui::prelude::PositionType>();

        app.register_foreign_lua_type::<bevy::ui::prelude::FlexWrap>();

        app.register_foreign_lua_type::<bevy::ui::prelude::GridAutoFlow>();

        app.register_foreign_lua_type::<bevy::ui::prelude::MinTrackSizingFunction>();

        app.register_foreign_lua_type::<bevy::ui::prelude::MaxTrackSizingFunction>();

        app.register_foreign_lua_type::<bevy::ui::prelude::GridTrack>();

        app.register_foreign_lua_type::<bevy::ui::prelude::GridTrackRepetition>();

        app.register_foreign_lua_type::<bevy::ui::prelude::RepeatedGridTrack>();

        app.register_foreign_lua_type::<bevy::ui::prelude::GridPlacement>();

        app.register_foreign_lua_type::<bevy::ui::prelude::BackgroundColor>();

        app.register_foreign_lua_type::<bevy::ui::prelude::BorderColor>();

        app.register_foreign_lua_type::<bevy::ui::prelude::Outline>();

        app.register_foreign_lua_type::<bevy::ui::prelude::UiImage>();

        app.register_foreign_lua_type::<bevy::ui::prelude::CalculatedClip>();

        app.register_foreign_lua_type::<bevy::ui::prelude::ZIndex>();

        app.register_foreign_lua_type::<bevy::ui::prelude::TargetCamera>();

        app.register_foreign_lua_type::<bevy::ui::prelude::UiScale>();
    }
}
